<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题1</title>
      <link href="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
      <url>/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><table><thead><tr><th>数据类型</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td>比如说 ，我想知道什么时候封锁一个正地址。Incrby 命令</td></tr><tr><td>Hash</td><td>存储用户信息[id,name,age]<br>Hset(key,field,value)<br>Hset(userKey,id,1)<br>Hset(userKey,name,admin)<br>Hset(userKey,age,10)<br>修改案例<br>Hget(userKey,id)<br>Hset(userKey,id,11)</td></tr><tr><td>List</td><td>实现最新消息的排行，还可以利用List的push命令，将任务存在1ist集合中，同时使用另一个命令，将任务从集合中职出[pop]<br>Redis-list数据类型来模拟消息队列。【电商中的秒杀就可以采用这种方式来完成一个秒杀活动】，</td></tr><tr><td>Set</td><td>特殊之处:可以自动排重。比如说微博中将每个人的好友存在集合(Set)中这样求两个人的共通好友的操作。我们只需要求交集即可。</td></tr><tr><td>Zset</td><td>以某一个条件为权重，进行排序。京东:商品详情的时候，都会有一个综合排名，还可以按照价格进行排名</td></tr></tbody></table><h1 id="1、JavaSE"><a href="#1、JavaSE" class="headerlink" title="1、JavaSE"></a>1、JavaSE</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><ul><li><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112200419360.png" alt="image-20241112200419360" style="zoom:50%;"></li></ul><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112200533751.png" alt="image-20241112200533751"></p><h2 id="2、什么是Singleton？"><a href="#2、什么是Singleton？" class="headerlink" title="2、什么是Singleton？"></a>2、什么是Singleton？</h2><p>Singleton：在Java中即指单例设计模式，他是软件开发中最常用的设计模式之一。</p><p>单：唯一，例：实例</p><p>单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。例如：代表JVM运行环境的Runtime类</p><p><strong>要点：</strong></p><ul><li><p>一是某个类只能有一个实例;</p><ul><li>构造器私有化</li></ul></li><li><p>二是它必须自行创建这个实例;</p><ul><li>含有一个该类的静态变量来保存这个唯一的实例</li></ul></li><li><p>三是它必须自行向整个系统提供这个实例:</p><ul><li><p>对外提供获取该实例对象的方式:</p><p>(1)直接暴露(2)用静态变量的get方法获取</p></li></ul></li></ul><p><strong>几种常见形式</strong></p><ul><li>饿汉式直接创建对象不存在线程安全问题<ul><li>直接实例化饿汉式(简若直观)</li><li>枚举式(最简洁)</li><li>静态代码块饿汉式(适合复杂实例化)</li></ul></li><li>懒汉式:延迟创建对象<ul><li>线程不安全(适用于单线程)</li><li>线程安全(适用于多线程)</li><li>静态内部类形式(适用于多线程 )</li></ul></li></ul><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112203428719.png" alt="image-20241112203428719"></p><p><strong>考点</strong></p><ul><li>类初始化过程</li><li>实例初始化过程</li><li>方法的重写</li></ul><p><strong>1、类初始化过程</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112203740810.png" alt="image-20241112203740810"></p><p><strong>2、实例初始化过程</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112204102190.png" alt="image-20241112204102190"></p><p><strong>3、方法的重写</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112204608758.png" alt="image-20241112204608758"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112204656539.png" alt="image-20241112204656539"></p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112204813890.png" alt="image-20241112204813890"></p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112204954839.png" alt="image-20241112204954839" style="zoom:33%;"><p><strong>考点</strong></p><ul><li>方法的参数传递机制</li><li>String、包装类等对象的不可变性</li></ul><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112205930800.png" alt="image-20241112205930800"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241112205947030.png" alt="image-20241112205947030"></p><h2 id="5、递归和循环迭代"><a href="#5、递归和循环迭代" class="headerlink" title="5、递归和循环迭代"></a>5、递归和循环迭代</h2><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113101141684.png" alt="image-20241113101141684"></p><h2 id="6、成员变量和局部变量"><a href="#6、成员变量和局部变量" class="headerlink" title="6、成员变量和局部变量"></a>6、成员变量和局部变量</h2><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113101342136.png" alt="image-20241113101342136"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113101347492.png" alt="image-20241113101347492"></p><p><strong>考点</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113101402418.png" alt="image-20241113101402418"></p><p><strong>局部变量和成员变量的区别</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113101940924.png" alt="image-20241113101940924"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113102140563.png" alt="image-20241113102140563"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113102215548.png" alt="image-20241113102215548"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113102223068.png" alt="image-20241113102223068"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113103049442.png" alt="image-20241113103049442"></p><p><strong>当局变量和xx变量重名时，区分</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113103214911.png" alt="image-20241113103214911"></p><h1 id="2、ssm"><a href="#2、ssm" class="headerlink" title="2、ssm"></a>2、ssm</h1><h2 id="1、bean的作用域有什么区别"><a href="#1、bean的作用域有什么区别" class="headerlink" title="1、bean的作用域有什么区别"></a>1、bean的作用域有什么区别</h2><p><strong>作用域</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113103323788.png" alt="image-20241113103323788"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113103332895.png" alt="image-20241113103332895"></p><h2 id="2、Spring支持的常用数据库事务传播属性和事务隔离级别"><a href="#2、Spring支持的常用数据库事务传播属性和事务隔离级别" class="headerlink" title="2、Spring支持的常用数据库事务传播属性和事务隔离级别"></a>2、Spring支持的常用数据库事务传播属性和事务隔离级别</h2><p><strong>事务的传播行为</strong></p><p>一个方法运行在了个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务</p><p>传播属性</p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241113104026729.png" alt="image-20241113104026729"></p><p><strong>事物的隔离级别</strong></p><p><strong>并发问题</strong></p><ol><li><p>脏读</p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115145350628.png" alt="image-20241115145350628" style="zoom:33%;"></li><li><p>不可重复读</p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115145404071.png" alt="image-20241115145404071" style="zoom:33%;"></li><li><p>幻读</p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115145415126.png" alt="image-20241115145415126" style="zoom:33%;"><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115145505518.png" alt="image-20241115145505518" style="zoom:33%;"></li></ol><p><strong>隔离级别</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115145715771.png" alt="image-20241115145715771"></p><h2 id="3、SpirngMVC-中如何解决Post请求中文乱码，Get又如何处理"><a href="#3、SpirngMVC-中如何解决Post请求中文乱码，Get又如何处理" class="headerlink" title="3、SpirngMVC 中如何解决Post请求中文乱码，Get又如何处理"></a>3、SpirngMVC 中如何解决Post请求中文乱码，Get又如何处理</h2><p>SpringMVC中提供了filter，CharacterEncodingFilter</p><p>get这么处理</p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241115151003872.png" alt="image-20241115151003872"></p><h2 id="4、SpringMVC工作流程"><a href="#4、SpringMVC工作流程" class="headerlink" title="4、SpringMVC工作流程"></a>4、SpringMVC工作流程</h2><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li><li>处理器映射器找到具体的处理器,生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li><li>Controller执行完成ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图</li><li>DispatcherServlet响应用户</li></ol><h2 id="5、Mybatis中实体类中的属性名和表中的字段名不一样怎么办？"><a href="#5、Mybatis中实体类中的属性名和表中的字段名不一样怎么办？" class="headerlink" title="5、Mybatis中实体类中的属性名和表中的字段名不一样怎么办？"></a>5、Mybatis中实体类中的属性名和表中的字段名不一样怎么办？</h2><p><strong>1、sql中起别名</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117095832854.png" alt="image-20241117095832854"></p><p><strong>2、在mybatis中开启驼峰命名规则</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117095925694.png" alt="image-20241117095925694"></p><p><strong>3、在Mapper映射文件中使用resultMap来自定义映射规则</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117100344156.png" alt="image-20241117100344156"></p><h1 id="3、Linux"><a href="#3、Linux" class="headerlink" title="3、Linux"></a>3、Linux</h1><h2 id="1、linux常用服务命令"><a href="#1、linux常用服务命令" class="headerlink" title="1、linux常用服务命令"></a>1、linux常用服务命令</h2><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117100428937.png" alt="image-20241117100428937" style="zoom:50%;"><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117100531930.png" alt="image-20241117100531930" style="zoom:50%;"><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117100636510.png" alt="image-20241117100636510" style="zoom:50%;"><h1 id="4、git"><a href="#4、git" class="headerlink" title="4、git"></a>4、git</h1><h2 id="1、git分支相关命令"><a href="#1、git分支相关命令" class="headerlink" title="1、git分支相关命令"></a>1、git分支相关命令</h2><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117100836337.png" alt="image-20241117100836337" style="zoom: 50%;"><h1 id="5、中间件redis"><a href="#5、中间件redis" class="headerlink" title="5、中间件redis"></a>5、中间件redis</h1><h2 id="1、redis持久化有几种类型"><a href="#1、redis持久化有几种类型" class="headerlink" title="1、redis持久化有几种类型"></a>1、redis持久化有几种类型</h2><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117101220671.png" alt="image-20241117101220671" style="zoom:50%;"><p><strong>RDB</strong></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117101249665.png" alt="image-20241117101249665" style="zoom:67%;"><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117101304094.png" alt="image-20241117101304094" style="zoom:67%;"><p><strong>AOF</strong></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117101600647.png" alt="image-20241117101600647" style="zoom:67%;"><h2 id="2、redis在项目中的使用场景"><a href="#2、redis在项目中的使用场景" class="headerlink" title="2、redis在项目中的使用场景"></a>2、redis在项目中的使用场景</h2><h1 id="6、数据库Mysql"><a href="#6、数据库Mysql" class="headerlink" title="6、数据库Mysql"></a>6、数据库Mysql</h1><h2 id="1、mysql什么时候建索引"><a href="#1、mysql什么时候建索引" class="headerlink" title="1、mysql什么时候建索引"></a>1、mysql什么时候建索引</h2><p><strong>索引</strong></p><p>MySQL官方对索引的定义为:索引(Index)是帮助MySQL高效获取数据的数据结构。可以得到索引的本质:索引是数据结构。</p><p>你可以简单理解为”排好序的快速查找数据结构”。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117102241163.png" alt="image-20241117102241163"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117102251844.png" alt="image-20241117102251844"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117102410309.png" alt="image-20241117102410309"></p><h1 id="7、JVM与GC机制"><a href="#7、JVM与GC机制" class="headerlink" title="7、JVM与GC机制"></a>7、JVM与GC机制</h1><h2 id="1、JVM垃圾回收机制"><a href="#1、JVM垃圾回收机制" class="headerlink" title="1、JVM垃圾回收机制"></a>1、JVM垃圾回收机制</h2><p>gc发生在堆区</p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117103902844.png" alt="image-20241117103902844"></p><p><strong>gc的算法</strong></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117103931168.png" alt="image-20241117103931168"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104009596.png" alt="image-20241117104009596"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104014865.png" alt="image-20241117104014865"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104044136.png" alt="image-20241117104044136"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104118400.png" alt="image-20241117104118400"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104150880.png" alt="image-20241117104150880"></p><p><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241117104202215.png" alt="image-20241117104202215"></p><h1 id="8、JUC与多线程"><a href="#8、JUC与多线程" class="headerlink" title="8、JUC与多线程"></a>8、JUC与多线程</h1><h2 id="1、volatile是什么"><a href="#1、volatile是什么" class="headerlink" title="1、volatile是什么"></a>1、volatile是什么</h2><p>volatile是java虚拟机提供的轻量级的同步机制</p><p><strong>保证可见性</strong></p><p><strong>不保证原子性</strong></p><p><strong>禁止指令重排</strong></p><h2 id="2、jmm内存模型的可见性"><a href="#2、jmm内存模型的可见性" class="headerlink" title="2、jmm内存模型的可见性"></a>2、jmm内存模型的可见性</h2><p>JMM(java内存模型Java Memory Model，简称JMM)本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。<strong>原子性、可见性、有序性</strong></p><ol><li><p>线程解锁前，必须把共享变量的值刷新回主内存</p></li><li><p>线程加锁前。必须读取主内存的最新值到自己的工作内存</p></li><li><p>加锁解锁是同一把锁</p><p>  由于JVM运行程序的实体是线程，而每个线程创建时JM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图:</p></li></ol><img src="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/image-20241118123411080.png" alt="image-20241118123411080" style="zoom:50%;"><h2 id="3、volatile不保证原子性"><a href="#3、volatile不保证原子性" class="headerlink" title="3、volatile不保证原子性"></a>3、volatile不保证原子性</h2><p><strong>原子性是什么意思</strong></p><p>不可分割，完整性，也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割。需要整体完整<br>要么同时成功，要么同时失败。</p><p>不保证原子性会出现<strong>写丢失</strong>的情况</p><p><strong>如何解决不保证原子性</strong></p><ul><li>加sync</li><li>使用juc下面的AtomicInteger</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2024/10/20/JavaWeb/"/>
      <url>/2024/10/20/JavaWeb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第三章、JavaScript"><a href="#第三章、JavaScript" class="headerlink" title="第三章、JavaScript"></a>第三章、JavaScript</h1><h2 id="1、JS简介"><a href="#1、JS简介" class="headerlink" title="1、JS简介"></a>1、JS简介</h2><p>Javascript，提供了数拆验证的基本功能。ECMA-262 是正式的Javascript 标准。这个标准基于Javascript (Netscape) 和JScript (Microsof)。ECMA-262 的开发始于1996年，在 1997年7月，ECMA会员大会采纳了它的首个版本。这个标准由ECMA组织发展和维护。JavaScript 的正式名称是”ECMAScript”。JavaScript的组成包含ECMASCrPt.DOM、BOM。JS是种运行于浏览器端上的小脚本语句,可以实现网页如文本内容动,数据动志变化和动画特效等,Js有 如下特点</p><ul><li>脚本语言<ul><li>Javascript是一种解释型的脚本语言，不同于C、C++、Java等语言先编译后执行，Javascript不会产生编译出来的字节码文件，而是在程序的运行过程中对源文件逐行进行解释。</li></ul></li><li>基于对象<ul><li>Javascript是一种基于对象的脚本语言，它不仅可以创建对象，也能使用现有的对象。但是面向对象的三大特性:「封装』、「继承』、「多态】中，javascript能够实现封装，可以模拟继承，不支持多态，所以它不是一门面向对象的编程语言。</li></ul></li><li>弱类型<ul><li>Jvascript中也有明确的数据类型，但是声明一个变量后它可以接收任何类型的数据，并且会在程序执行过程中根掘上下文自动转换类型。</li></ul></li><li>事件驱动<ul><li>Javascript是一种采用事件驱动的脚本语言，它不需要经过Web服务器就可以对用户的输入做出响应。</li></ul></li><li>跨平台性<ul><li>Javascript脚本语言不依赖于操作系统，仅需要浏览器的支持。因此一个Javascript脚本在编写后可以带到任意机器上使用，前提是机器上的浏览器支持Javascript脚本语言。目前JavaScript已被大多数的浏览器所支持。</li></ul></li></ul><h3 id="1-1JS组成"><a href="#1-1JS组成" class="headerlink" title="1.1JS组成"></a>1.1JS组成</h3><p><img src="/2024/10/20/JavaWeb/image-20241020153532133.png" alt="image-20241020153532133"></p><h3 id="1-2JS的引入"><a href="#1-2JS的引入" class="headerlink" title="1.2JS的引入"></a>1.2JS的引入</h3><ol><li>js的第一种引入方式，在head中通过一对script标签引入</li><li>可以将JS代码放入一个.is文件中，在HTML的head中用一对script标签引入外部JS脚本</li></ol><p><strong>两种方式可以同时使用</strong></p><h2 id="2、JS的数据类型和运算符"><a href="#2、JS的数据类型和运算符" class="headerlink" title="2、JS的数据类型和运算符"></a>2、JS的数据类型和运算符</h2><h3 id="2-1-JS的数据类型"><a href="#2-1-JS的数据类型" class="headerlink" title="2.1 JS的数据类型"></a>2.1 JS的数据类型</h3><ul><li><p><strong>数值类型</strong></p><p>数值类型统-为 number,不区分整数和浮点数</p></li><li><p><strong>字符串类型</strong></p><p>字符串类型为 string 和JAVA中的string相似,JS中不严格区分单双引号,都可以用于表示字符串</p></li><li><p><strong>布尔类型</strong></p><p>布尔类型为boolean 和Java中的boolean相似,但是在」s的if语句中,非空字符串会被转换为’真,非零数字也会被认为是”真</p></li><li><p><strong>引用数据类型</strong></p><p>引用数据类型对象是0bject类型,各种对象和数组在JS中都是obiect类型</p></li><li><p><strong>function类型</strong></p><p>JS中的各种函数属于function数据类型</p></li><li><p><strong>命名未赋值</strong></p><p>is为弱类型语言,统一使用 var 声明对象和变量,在赋值时才确定真正的数据类型,变量如果只声明没有赋值的话,数据类型为undefined</p></li><li><p>赋予NULL值</p><p>在JS中,如果给一个变量赋值为null,其数据类型是0bject,可以通过typeof关键字判断数据类型</p></li></ul><h3 id="2-2-JS变量"><a href="#2-2-JS变量" class="headerlink" title="2.2 JS变量"></a>2.2 JS变量</h3><ol><li>弱类型变量,可以统一声明成var</li><li>var声明的变量可以再次声明</li><li>变量可以使用不同的数据类型多次赋值</li><li>JS的语句可以以:结尾,也可以不用:结尾</li><li>变量标识符严格区分大小写</li><li>标识符的命名规则参照JAVA</li><li>如果使用了 一个没有声明的变量,那么运行时会报ncaught ReferenceError: ***is not defined at index.html:行号:列号</li><li>如果一个变量只声明,没赋值,那么值是undefined</li></ol><h3 id="2-3-JS运算符"><a href="#2-3-JS运算符" class="headerlink" title="2.3 JS运算符"></a>2.3 JS运算符</h3><p><img src="/2024/10/20/JavaWeb/image-20241020162113862.png" alt="image-20241020162113862"></p><p><img src="/2024/10/20/JavaWeb/image-20241020162638529.png" alt="image-20241020162638529"></p><h2 id="3、JS的流程控制和函数"><a href="#3、JS的流程控制和函数" class="headerlink" title="3、JS的流程控制和函数"></a>3、JS的流程控制和函数</h2><h3 id="3-1-JS分支结构"><a href="#3-1-JS分支结构" class="headerlink" title="3.1 JS分支结构"></a>3.1 JS分支结构</h3><p><img src="/2024/10/20/JavaWeb/image-20241020164304487.png" alt="image-20241020164304487"></p><h3 id="3-2-JS循环结构"><a href="#3-2-JS循环结构" class="headerlink" title="3.2 JS循环结构"></a>3.2 JS循环结构</h3><p><img src="/2024/10/20/JavaWeb/image-20241020164521303.png" alt="image-20241020164521303"></p><p><img src="/2024/10/20/JavaWeb/image-20241020164631539.png" alt="image-20241020164631539"></p><p><img src="/2024/10/20/JavaWeb/image-20241020164656741.png" alt="image-20241020164656741"></p><h3 id="3-3-JS函数声明"><a href="#3-3-JS函数声明" class="headerlink" title="3.3 JS函数声明"></a>3.3 JS函数声明</h3><p><img src="/2024/10/20/JavaWeb/image-20241020164850082.png" alt="image-20241020164850082"></p><h2 id="4、Js的对象和JSON"><a href="#4、Js的对象和JSON" class="headerlink" title="4、Js的对象和JSON"></a>4、Js的对象和JSON</h2><h3 id="4-1-JS声明对象的语法"><a href="#4-1-JS声明对象的语法" class="headerlink" title="4.1 JS声明对象的语法"></a>4.1 JS声明对象的语法</h3><p><img src="/2024/10/20/JavaWeb/image-20241020170355863.png" alt="image-20241020170355863"></p><p><img src="/2024/10/20/JavaWeb/image-20241020170901554.png" alt="image-20241020170901554"></p><h3 id="4-2-JSON格式"><a href="#4-2-JSON格式" class="headerlink" title="4.2 JSON格式"></a>4.2 JSON格式</h3><p><img src="/2024/10/20/JavaWeb/image-20241020191839363.png" alt="image-20241020191839363"></p><p><img src="/2024/10/20/JavaWeb/image-20241020192013474.png" alt="image-20241020192013474"></p><p><strong>前端中JSON数据转换</strong></p><p><img src="/2024/10/20/JavaWeb/image-20241020192711471.png" alt="image-20241020192711471"></p><p><strong>后端中JSON数据转换</strong>，反射</p><p><img src="/2024/10/20/JavaWeb/image-20241020193717619.png" alt="image-20241020193717619"></p><p><img src="/2024/10/20/JavaWeb/image-20241020193747489.png" alt="image-20241020193747489"></p><h3 id="4-3-JS常见对象"><a href="#4-3-JS常见对象" class="headerlink" title="4.3 JS常见对象"></a>4.3 JS常见对象</h3><p><a href="https://www.runoob.com/">菜鸟教程</a></p><p>可以在这里看API</p><h4 id="4-3-1-数组"><a href="#4-3-1-数组" class="headerlink" title="4.3.1 数组"></a>4.3.1 数组</h4><p><img src="/2024/10/20/JavaWeb/image-20241020193910493.png" alt="image-20241020193910493"></p><h4 id="4-3-2-Boolean对象"><a href="#4-3-2-Boolean对象" class="headerlink" title="4.3.2 Boolean对象"></a>4.3.2 Boolean对象</h4><p><img src="/2024/10/20/JavaWeb/image-20241020195327234.png" alt="image-20241020195327234"></p><h4 id="4-3-3-Date对象"><a href="#4-3-3-Date对象" class="headerlink" title="4.3.3 Date对象"></a>4.3.3 Date对象</h4><h4 id="4-3-4-Math"><a href="#4-3-4-Math" class="headerlink" title="4.3.4 Math"></a>4.3.4 Math</h4><h4 id="4-3-5-Number"><a href="#4-3-5-Number" class="headerlink" title="4.3.5 Number"></a>4.3.5 Number</h4><h4 id="4-3-6-String"><a href="#4-3-6-String" class="headerlink" title="4.3.6 String"></a>4.3.6 String</h4><h2 id="5、事件的绑定"><a href="#5、事件的绑定" class="headerlink" title="5、事件的绑定"></a>5、事件的绑定</h2><h3 id="5-1-什么是事件"><a href="#5-1-什么是事件" class="headerlink" title="5.1 什么是事件"></a>5.1 什么是事件</h3><p><img src="/2024/10/20/JavaWeb/image-20241020200348756.png" alt="image-20241020200348756"></p><h3 id="5-2-常见事件"><a href="#5-2-常见事件" class="headerlink" title="5.2 常见事件"></a>5.2 常见事件</h3><p><strong>鼠标事件</strong></p><p><img src="/2024/10/20/JavaWeb/image-20241020200408972.png" alt="image-20241020200408972"></p><p><strong>键盘事件</strong></p><p><img src="/2024/10/20/JavaWeb/image-20241020200458099.png" alt="image-20241020200458099"></p><h2 id="6、BOM编程"><a href="#6、BOM编程" class="headerlink" title="6、BOM编程"></a>6、BOM编程</h2><h3 id="6-1什么是BOM"><a href="#6-1什么是BOM" class="headerlink" title="6.1什么是BOM"></a>6.1什么是BOM</h3><p><img src="/2024/10/20/JavaWeb/image-20241021172501726.png" alt="image-20241021172501726"></p><p><img src="/2024/10/20/JavaWeb/image-20241021172724960.png" alt="image-20241021172724960"></p><p><img src="/2024/10/20/JavaWeb/image-20241021172740318.png" alt="image-20241021172740318"></p><p><img src="/2024/10/20/JavaWeb/image-20241021174108654.png" alt="image-20241021174108654"></p><p><img src="/2024/10/20/JavaWeb/image-20241021174128954.png" alt="image-20241021174128954"></p><p><img src="/2024/10/20/JavaWeb/image-20241021174820236.png" alt="image-20241021174820236"></p><h2 id="7、DOM编程"><a href="#7、DOM编程" class="headerlink" title="7、DOM编程"></a>7、DOM编程</h2><p><img src="/2024/10/20/JavaWeb/image-20241021175036624.png" alt="image-20241021175036624"></p><p><img src="/2024/10/20/JavaWeb/image-20241021180230751.png" alt="image-20241021180230751"></p><p><img src="/2024/10/20/JavaWeb/image-20241021195153160.png" alt="image-20241021195153160"></p><p><img src="/2024/10/20/JavaWeb/image-20241021201002434.png" alt="image-20241021201002434"></p><p><img src="/2024/10/20/JavaWeb/image-20241021200740322.png" alt="image-20241021200740322"></p><p><img src="/2024/10/20/JavaWeb/image-20241021195958649.png" alt="image-20241021195958649"></p><h2 id="8、正则表达式"><a href="#8、正则表达式" class="headerlink" title="8、正则表达式"></a>8、正则表达式</h2><h3 id="8-1-正则表达式简介"><a href="#8-1-正则表达式简介" class="headerlink" title="8.1 正则表达式简介"></a>8.1 正则表达式简介</h3><p><img src="/2024/10/20/JavaWeb/image-20241024110819103.png" alt="image-20241024110819103"></p><h3 id="8-2-正则表达式体验"><a href="#8-2-正则表达式体验" class="headerlink" title="8.2 正则表达式体验"></a>8.2 正则表达式体验</h3><p><img src="/2024/10/20/JavaWeb/image-20241024110947797.png" alt="image-20241024110947797"></p><h1 id="第四章、XML"><a href="#第四章、XML" class="headerlink" title="第四章、XML"></a>第四章、XML</h1><h2 id="1、XML"><a href="#1、XML" class="headerlink" title="1、XML"></a>1、XML</h2><p><img src="/2024/10/20/JavaWeb/image-20241024111147268.png" alt="image-20241024111147268"></p><p><img src="/2024/10/20/JavaWeb/image-20241024111228396.png" alt="image-20241024111228396"></p><p><img src="/2024/10/20/JavaWeb/image-20241024111240995.png" alt="image-20241024111240995"></p><p><img src="/2024/10/20/JavaWeb/image-20241024111756935.png" alt="image-20241024111756935"></p><p><img src="/2024/10/20/JavaWeb/image-20241024112008549.png" alt="image-20241024112008549"></p><p><img src="/2024/10/20/JavaWeb/image-20241024112215906.png" alt="image-20241024112215906"></p><h2 id="2、Tomcat10"><a href="#2、Tomcat10" class="headerlink" title="2、Tomcat10"></a>2、Tomcat10</h2><h3 id="2-1-web"><a href="#2-1-web" class="headerlink" title="2.1 web"></a>2.1 web</h3><p><img src="/2024/10/20/JavaWeb/image-20241024112305613.png" alt="image-20241024112305613"></p><img src="/2024/10/20/JavaWeb/image-20241024112331835.png" alt="image-20241024112331835" style="zoom:50%;"><h3 id="2-2-tomcat服务器"><a href="#2-2-tomcat服务器" class="headerlink" title="2.2 tomcat服务器"></a>2.2 tomcat服务器</h3><p><img src="/2024/10/20/JavaWeb/image-20241024112402140.png" alt="image-20241024112402140"></p><p><img src="/2024/10/20/JavaWeb/image-20241024112546969.png" alt="image-20241024112546969"></p><p><img src="/2024/10/20/JavaWeb/image-20241024112641307.png" alt="image-20241024112641307"></p><h3 id="2-3web目录"><a href="#2-3web目录" class="headerlink" title="2.3web目录"></a>2.3web目录</h3><p><img src="/2024/10/20/JavaWeb/image-20241024151909474.png" alt="image-20241024151909474"></p><p><img src="/2024/10/20/JavaWeb/image-20241024151953587.png" alt="image-20241024151953587"></p><h3 id="2-4-web部署方式"><a href="#2-4-web部署方式" class="headerlink" title="2.4 web部署方式"></a>2.4 web部署方式</h3><p><img src="/2024/10/20/JavaWeb/image-20241024152002181.png" alt="image-20241024152002181"></p><h2 id="3、HTTP协议"><a href="#3、HTTP协议" class="headerlink" title="3、HTTP协议"></a>3、HTTP协议</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><h4 id="3-1-1-历程"><a href="#3-1-1-历程" class="headerlink" title="3.1.1 历程"></a>3.1.1 历程</h4><p><img src="/2024/10/20/JavaWeb/image-20241024224750730.png" alt="image-20241024224750730"></p><p><img src="/2024/10/20/JavaWeb/image-20241024224800568.png" alt="image-20241024224800568"></p><p><img src="/2024/10/20/JavaWeb/image-20241024224844808.png" alt="image-20241024224844808"></p><h4 id="3-1-2-HTTP协议的会话方式"><a href="#3-1-2-HTTP协议的会话方式" class="headerlink" title="3.1.2 HTTP协议的会话方式"></a>3.1.2 HTTP协议的会话方式</h4><p><img src="/2024/10/20/JavaWeb/image-20241024225026641.png" alt="image-20241024225026641"></p><h4 id="3-1-3-HTTP1-0和1-1的区别"><a href="#3-1-3-HTTP1-0和1-1的区别" class="headerlink" title="3.1.3 HTTP1.0和1.1的区别"></a>3.1.3 HTTP1.0和1.1的区别</h4><p><img src="/2024/10/20/JavaWeb/image-20241031163012428.png" alt="image-20241031163012428"></p><h3 id="3-2请求和响应报文"><a href="#3-2请求和响应报文" class="headerlink" title="3.2请求和响应报文"></a>3.2请求和响应报文</h3><h4 id="3-2-1报文格式"><a href="#3-2-1报文格式" class="headerlink" title="3.2.1报文格式"></a>3.2.1报文格式</h4><p><img src="/2024/10/20/JavaWeb/image-20241031165910964.png" alt="image-20241031165910964"></p><p><img src="/2024/10/20/JavaWeb/image-20241031165939418.png" alt="image-20241031165939418"></p><h4 id="3-2-2-请求报文"><a href="#3-2-2-请求报文" class="headerlink" title="3.2.2 请求报文"></a>3.2.2 请求报文</h4><p><img src="/2024/10/20/JavaWeb/image-20241102180729088.png" alt="image-20241102180729088"></p><p><img src="/2024/10/20/JavaWeb/image-20241102180741743.png" alt="image-20241102180741743"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bagu</title>
      <link href="/2024/10/10/bagu/"/>
      <url>/2024/10/10/bagu/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><p id="101"></p><h2 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h2><p>相似点：<br>（1）接口和抽象类都不能实例化，<br>（2）实现接口或者继承抽象类的普通子类都必须实现这些抽象方法。<br>不同点：<br>（1）抽象类可以包含普通方法和代码块，接口类中只能有抽象方法，静态方法和默认方法，<br>（2）抽象类可以有构造方法，接口没有，<br>（3）抽象类的成员变量可以是各种类型的，接口类中只能是public static final类型的，并且必须赋值。</p><p id="102"></p><h2 id="2-重载和重写方法的区别"><a href="#2-重载和重写方法的区别" class="headerlink" title="2.重载和重写方法的区别"></a>2.重载和重写方法的区别</h2><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同；<br>重写发生在子类中，方法名、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写。</p><p id="103"></p><h2 id="3-Java中hashCode和equals方法是什么？和-有什么区别"><a href="#3-Java中hashCode和equals方法是什么？和-有什么区别" class="headerlink" title="3.Java中hashCode和equals方法是什么？和&#x3D;&#x3D;有什么区别"></a>3.Java中hashCode和equals方法是什么？和&#x3D;&#x3D;有什么区别</h2><p>hashCode用于散列存储结构中确定对象的存储位置。可用于快速比较两个对象是否相同，因为如果他们的哈希码不同，那么肯定不相等。<br>equals用于比较两个对象的内容是否相等，通常需要重写自定义比较逻辑。<br>=&#x3D;比较基本数据类型，比较它们的值；比较引用类型，比较内存地址。</p><p id="104"></p><h2 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h2><p>（1）使用try-catch-finally捕获异常，finally中的代码一定会执行，捕获异常后程序正常进行；<br>（2）使用throws声明该方法可能会抛出异常类型，出现异常类型后，程序终止。</p><p id="105"></p><h2 id="5-Java优势是什么"><a href="#5-Java优势是什么" class="headerlink" title="5.Java优势是什么"></a>5.Java优势是什么</h2><p><strong>跨平台</strong><br>首先java是跨平台的，不同平台执行的机器码是不一样的，而java因为加了一层中间层JVM，所以可以做到一次编写多平台运行，即[Write once,Run anywhere]<br>编译执行过程是先把Java源代码编译成字节码，字节码再由JVM解释或JI编译执行，而因为JIT编译时需要预热的，所以还提供了AOT，可以直接把字节码转成机器码，来让程序重启之后能迅速拉满战斗力。<br><strong>垃圾回收</strong><br>Java还提供垃圾自动回收功能，虽说手动管理内存意味着自由、精细化地掌控，但很容易出错。<br>在内存充裕的当下，将内存的管理交给GC来做，减轻了程序员编程的负担，提升了开发的效率。<br><strong>生态</strong><br>现在Java生态圈太全了，丰富的第三方类库、网上全面的资料、企业级框架、各种中间件等等。</p><p><strong>补充</strong></p><ul><li>1.简单易学、有丰富的类库</li><li>2.面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</li><li>3.与平台无关性（JVM是Java跨平台使用的根本）</li><li>4.可靠安全</li><li>5.支持多线程</li></ul><p id="106"></p><h2 id="6-什么是Java地多态特性"><a href="#6-什么是Java地多态特性" class="headerlink" title="6.什么是Java地多态特性"></a>6.什么是Java地多态特性</h2><p>多态其实是一种抽象行为，他的主要作用是让程序员可以面对抽象编程而不是具体的实现类，这样写出来的代码扩展性会更强。<br>比如某个人很喜欢吃苹果，我们在写文章描述他的时候可以写他很喜欢吃苹果，也可以写他很喜欢吃水果。<br>水果就是抽象，苹果就是具体的实现类。<br>假设这个人某天开始换口味了，他喜欢吃桃子了，如果我们之前的文章写的是水果，那么完全不需要改，如果写的是苹果，是不是需要把苹果替换成桃子了?<br>这就是多态的意义。</p><p>多态地实现要有继承、重写、父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</p><p id="107"></p><h2 id="7-HashMap原理"><a href="#7-HashMap原理" class="headerlink" title="7.HashMap原理"></a>7.HashMap原理</h2><p>1.HashMap在JDK1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全  2.HashMap扩容机制：<br>HashMap的默认容量是16，默认的负载因子是0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树。<br>3.HashMap存取原理<br>（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置。<br>（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表(JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移会发生数据覆盖的情况)</p> <p id="108"></p><h2 id="8-面向对象和面向过程的区别"><a href="#8-面向对象和面向过程的区别" class="headerlink" title="8.面向对象和面向过程的区别"></a>8.面向对象和面向过程的区别</h2><p><strong>面向对象：</strong> 是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。<br><strong>面向过程：</strong> 是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题地过程中所发生的行为。面向对象有封装继承多态的特性，所以易于维护、易服用、易扩展。可以设计出低耦合的系统。但是性能上来说，比面向过程要低。</p><p id="109"></p><h2 id="9-Java的自动装箱和拆箱"><a href="#9-Java的自动装箱和拆箱" class="headerlink" title="9.Java的自动装箱和拆箱"></a>9.Java的自动装箱和拆箱</h2><p><strong>装箱就是自动将基本数据类型转换为包装器类型（int-&gt;Integer）;调用方法：Integer的valueOf（int）方法<br>拆箱就是自动将包装器类型转换为基本数据类型（Integer-&gt;int）；调用方法：Inerger的intValue方法</strong></p><p><img src="/2024/10/10/bagu/bagu4-1728549801847-1.png" alt="bagu4"></p><p>输出结果表示i1和i2是一个对象，i3和i4不是一个对象。<br>从两个实现类的源码来看，通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已存在的对象的引用；否则创建一个新的Integer对象。<br>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2 指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p><p><img src="/2024/10/10/bagu/bagu5-1728549807046-3.png" alt="bagu5"></p><p>原因：在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p><p id="110"></p><h2 id="10-Hashcode的作用"><a href="#10-Hashcode的作用" class="headerlink" title="10.Hashcode的作用"></a>10.Hashcode的作用</h2><p>java的集合有两类，一类是list，一类是Set。前者有序可重复，后者无序不可重复。当我们在set中插入时候怎么判断是否已经存在该元素呢，可以通过equals方法，但是如果元素太多，就会比较慢。<br>于是有人发明了哈希算法来提高集合中查找元素的效率。这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的哪个区域。<br>hashcode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p><p id="111"></p><h2 id="11-ArrayList和LinkedList的区别"><a href="#11-ArrayList和LinkedList的区别" class="headerlink" title="11.ArrayList和LinkedList的区别"></a>11.ArrayList和LinkedList的区别</h2><p><strong>ArrayList:</strong></p><ul><li>优点: ArrayList是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高。</li><li>缺点：因为地址连续，ArrayList要移动数据，所以插入和删除操作效率比较低。</li></ul><p><strong>LinkedList：</strong></p><ul><li>优点：LinkedList基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList比较占优势。LinkedList适用于要头尾操作或插入指定位置的场景。</li><li>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</li></ul><p><strong>使用场景分析：</strong></p><ul><li>当需要对数据进行随机访问的时候，选用ArrayList；</li><li>当需要对数据进行多次增加删除修改时，采用LinkedList。</li></ul><p>如果容量固定，并且只会添加到尾部，不引起扩容，优先采用ArrayList。</p><p>当然绝大多数业务的场景下，使用ArrayList就够了，但是需要注意避免ArrayList的扩容，以及非顺序的插入。</p><h2 id="12-HashMap和HashTable的区别"><a href="#12-HashMap和HashTable的区别" class="headerlink" title="12.HashMap和HashTable的区别"></a>12.HashMap和HashTable的区别</h2><h3 id="1、两者父类不同"><a href="#1、两者父类不同" class="headerlink" title="1、两者父类不同"></a>1、两者父类不同</h3><h3 id="2、对外提供的接口不同"><a href="#2、对外提供的接口不同" class="headerlink" title="2、对外提供的接口不同"></a>2、对外提供的接口不同</h3><h3 id="3、对null的支持不同"><a href="#3、对null的支持不同" class="headerlink" title="3、对null的支持不同"></a>3、对null的支持不同</h3><h3 id="4、安全性不同"><a href="#4、安全性不同" class="headerlink" title="4、安全性不同"></a>4、安全性不同</h3><h3 id="5、初始容量大小和每次扩充容量大小不同"><a href="#5、初始容量大小和每次扩充容量大小不同" class="headerlink" title="5、初始容量大小和每次扩充容量大小不同"></a>5、初始容量大小和每次扩充容量大小不同</h3><h3 id="6、计算hash值方法不同"><a href="#6、计算hash值方法不同" class="headerlink" title="6、计算hash值方法不同"></a>6、计算hash值方法不同</h3><h2 id="13、泛型常用特点"><a href="#13、泛型常用特点" class="headerlink" title="13、泛型常用特点"></a>13、泛型常用特点</h2><p>泛型的定义：</p><p>顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如ArrayList作为集合可以存放各种元素，如Integer，String，自定义的各种类型等，但我们使用的时候可以通过具体的规则来约束，如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>使用泛型的好处：</p><ol><li>我们不必因为添加元素类型的不同而定义不同类型的集合；</li><li>我们可以通过规则按照自己的想法控制存储的数据类型。</li></ol><h2 id="14、Java创建对象有几种方式"><a href="#14、Java创建对象有几种方式" class="headerlink" title="14、Java创建对象有几种方式"></a>14、Java创建对象有几种方式</h2><p>四种方式：</p><p><strong>new创建新对象</strong></p><p><strong>通过反射机制</strong></p><p>使用 newInstance()，但是得处理两个异常 InstantiationException、 IllegalAccessException ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user=User.class.newInstance();</span><br><span class="line"> Object object=(Object)Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).newInstance()</span><br></pre></td></tr></table></figure><p><strong>采用clone机制</strong></p><p><strong>通过序列化机制</strong></p><p>调用 ObjectInputStream 类的 readObject() 方法。 我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造 函 数。 一个对象实现了 Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创 建对 象。</p><h2 id="15、有没有可能两个不相等的对象有相同的hashcode"><a href="#15、有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="15、有没有可能两个不相等的对象有相同的hashcode"></a>15、有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能。在产生hash冲突时，两个不相等的对象就会有相同的hashcode值。当hash冲突产生时，一般有以下几种方式：</p><ol><li>拉链法:  每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一 个单向链 表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </li><li>开放地址法：：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散 列地址总 能找到，并将记录存入;</li><li>在哈希：又叫双哈希法，有多个不同的Hash函数.当发生冲突时，使用第二个，第三个…. 等哈希函数 计算地址，直到无冲突。</li></ol><p id="2"></p><h2 id="16、深拷贝和浅拷贝的区别是什么"><a href="#16、深拷贝和浅拷贝的区别是什么" class="headerlink" title="16、深拷贝和浅拷贝的区别是什么"></a>16、深拷贝和浅拷贝的区别是什么</h2><ul><li>浅拷贝：<strong>增加了一个指针只想已存在的内存地址。</strong>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li><li>深拷贝：<strong>增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</strong>被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制过的新对象。而不再是原有的那些被引用的对象。换言之，深拷贝把复制的对象所引用的对象都复制了一遍。</li></ul><h2 id="17、final的用法"><a href="#17、final的用法" class="headerlink" title="17、final的用法"></a>17、final的用法</h2><ul><li>被final修饰的类不可以被继承；</li><li>被final修饰的方法不可以被重写；</li><li>被final修饰的变量不可以被改变；如果修饰引用，那么引用不可变，引用指向的内容可变；</li><li>被final修饰的方法，JVM会尝试将其内联，提高运行效率；</li><li>被final修饰的常量，再编译阶段会存入常量池中。</li></ul><h2 id="18、a-a-b和a-b有什么区别"><a href="#18、a-a-b和a-b有什么区别" class="headerlink" title="18、a&#x3D;a+b和a+&#x3D;b有什么区别"></a>18、a&#x3D;a+b和a+&#x3D;b有什么区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b=a+b;<span class="comment">//编译错误：cannot convert from int to byte</span></span><br><span class="line">b+=a;</span><br></pre></td></tr></table></figure><p>+&#x3D;操作符会对右边的表达式结果强制匹配左边的数据类型</p><h2 id="19、try-catch-finally-try里有return-finally还执行吗？"><a href="#19、try-catch-finally-try里有return-finally还执行吗？" class="headerlink" title="19、try catch finally,try里有return,finally还执行吗？"></a>19、try catch finally,try里有return,finally还执行吗？</h2><p>执行，并且finally的执行早于try里面的return</p><p><strong>结论：</strong></p><p>1、不管有没有出现异常，finally块中代码都会执行；</p><p>2、当try和catch中有return时，finally仍然会执行；</p><p>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值时再finally执行前确定的；</p><p>4、finally中最好不要包含return，否则会提前退出，返回值不是try和catch中保存的值。</p><h2 id="20、Excption与Error包结构"><a href="#20、Excption与Error包结构" class="headerlink" title="20、Excption与Error包结构"></a>20、Excption与Error包结构</h2><p><strong>java可抛出（Throwable）的结构分为三种类型：被检查的异常(CheckedException)，运行时的异常(RuntimeException)，和错误(Error)</strong></p><ol><li>运行时异常</li></ol><ul><li>定义:RuntimeException 及其子类都被称为运行时异常。</li><li></li></ul><h2 id="21、OOM你遇到过哪些情况，SOF你遇到过哪些情况"><a href="#21、OOM你遇到过哪些情况，SOF你遇到过哪些情况" class="headerlink" title="21、OOM你遇到过哪些情况，SOF你遇到过哪些情况"></a>21、OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><p><strong>OOM:</strong></p><ol><li><p><strong>OutOfMemoryError异常</strong></p><p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生</p><p>OutOfMemoryError（OOM）异常的可能。</p><p>Java Heap 溢出：</p><p>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。</p><p>java堆用于存储对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这些对象数量达到最大堆容量限制后产生内存溢出异常。出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清时因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p><p>如果是内存泄漏，可进一步通过工具查看泄露对象到GCRoots的引用链。于是就能找到泄露对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收。</p><p>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p></li><li><p><strong>虚拟机栈和本地方法栈溢出</strong></p><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常，这里需要注意当栈的大小越大可分配的线程数就越少。</p></li><li><p><strong>运行时常量池溢出</strong></p><p>异常信息：java.lang.OutOfMemoryError:PermGenspace</p><p>如果要向运行时常量池中添加内容，最简单的做法就是使用String，intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于 常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从 而间接限制其中常量池的容量。</p></li><li><p><strong>方法区溢出</strong></p><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有 可 能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。 异常信息：java.lang.OutOfMemoryError:PermGenspace 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛 刻 的。在经常动态生成大量Class的应用中，要特别注意这点。</p></li></ol><p><strong>SOF（堆栈溢出StackOverflow）</strong></p><p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。 因为栈一般默认为1—2m ，一旦出现死循环或者是大量的递归调用，在不断地压栈过程中，造成 栈容 量超过1m而导致溢出。 栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、 List、map数据过大。</p><h2 id="22、简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#22、简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="22、简述线程、程序、进程的基本概念。以及他们之间关系是什么"></a>22、简述线程、程序、进程的基本概念。以及他们之间关系是什么</h2><p><strong>线程</strong>与进程类似，但是线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或者在各个线程之间做切换工作时，负担比进程小得多，所以县城被称为轻量级进程。</p><p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或者其他的数据存储设备中，也就是说程序是静态的代码。</p><p><strong>进程</strong>是程序的依次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p><p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的， 而 各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p><h2 id="23、、Java中IO流"><a href="#23、、Java中IO流" class="headerlink" title="23、、Java中IO流"></a>23、、Java中IO流</h2><p><strong>Java中IO流分几种</strong></p><ul><li>按照流的流向分，输入流和输出流</li><li>按照操作单元分，字节流和字符流</li><li>按照流的角色分，节点流和处理流</li></ul><p>JavaIO流的40多个类都是从如下4个抽象基类派生出来的</p><ul><li><strong>InputStream&#x2F;Reader</strong>：所有的输入流的基类，前者是字节输入流，后者是字符输入流</li><li><strong>OutputStream&#x2F;Writer</strong>：所有的输出流的基类，前者是字节输出流，后者是字符输出流</li></ul><p>按操作方式分类：</p><p><img src="/2024/10/10/bagu/bagu2.png" alt="bagu2"></p><p>按操作对象分类分：</p><p><img src="/2024/10/10/bagu/bagu1.png" alt="bagu1"></p><h2 id="24、Java反射的作用原理"><a href="#24、Java反射的作用原理" class="headerlink" title="24、Java反射的作用原理"></a>24、Java反射的作用原理</h2><p><strong>1、定义：</strong></p><p>反射机制是在运行时，对于任意的一个类，都能知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p>​这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</p><p><strong>2、哪里会用到反射机制</strong></p><p>jdbc就是典型的反射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载 MySQL 的驱动类</span></span><br></pre></td></tr></table></figure><p><strong>3、反射的实现方式</strong></p><p>获取Class对象，有四种方法：</p><ol><li>Class.forName(“类的路径”）；</li><li>类名.class</li><li>对象 名.getClass() </li><li>基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class 对象</li></ol><p><strong>4、实现Java反射的类：</strong></p><ol><li>Class：表示正在运行的Java应用程序中的类和接口 注意： 所有获取对象的信息都需要Class 类 来实现。</li><li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</li><li>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限 。</li><li>Method：提供类或接口 中某个方法的信息。</li></ol><p><strong>5、反射机制的优缺点</strong></p><p>优点：</p><ul><li>能够运行时动态获取类的实例，提高灵活性；</li><li>与动态编译结合</li></ul><p>缺点：</p><ul><li><p>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p><p><strong>解决方案：</strong></p><ol><li>通过setAccessible(true) 关闭JDK的安全检查来提升反射速度；</li><li>多次创建一个类的实例时，有缓存会快很多</li><li>ReflectASM 工具类，通过字节码生成的方式加快反射速度</li></ol></li><li><p>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p></li></ul><h2 id="25、List，Set，Map三者区别"><a href="#25、List，Set，Map三者区别" class="headerlink" title="25、List，Set，Map三者区别"></a>25、List，Set，Map三者区别</h2><p><strong>List , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口</strong></p><ul><li><p><strong>List(对付顺序的好帮手，有序可重复)：</strong>List接口存储一组不唯一(可以有多个元素引用相同的对象)，有序的对象；</p></li><li><p><strong>Set(注重独一无二的性质，无序，唯一)：</strong>不允许重复的集合。不会有多个元素引用相同的对象；</p></li><li><p><strong>Map(用Key搜索的专家)：</strong>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但是key不能重复，典型的Key是String类型，但也可以是任何对象。</p></li><li><p>Set下有<strong>HashSet，LinkedHashSet，TreeSet</strong></p></li><li><p>List下有<strong>ArrayList，Vector，LinkedList</strong></p></li><li><p>Map下有<strong>Hashtable，LinkedHashMap，HashMap，TreeMap</strong></p></li></ul><p><strong>笔记</strong></p><p>**List 的常用方法 **</p><ul><li><p>.add()：向集合中添加数据；</p></li><li><p>.remove(); &#x2F;&#x2F;可以是index和Object类型。Object移除第一次出现的指定元素。</p></li><li><p>.indexOf(“ab”);<em>返回第一个字符的下标</em></p></li><li><p>.lastIndexOf(“a”);<em>返回最后一个字符的下标</em></p></li><li><p>.size()：统计集合中有多少元素（元素可以重复储存）</p></li><li><p>.get(index);获取对应位置index的数据，用法与数组相似，从零开始计数。</p></li><li><p>.set(index,obj); &#x2F;&#x2F;修改集合的数值</p></li><li><p>.contains(Object o) &#x2F;&#x2F;list是否包含对象o;</p></li><li><p>.clear &#x2F;&#x2F;移除所有元素;</p></li><li><p>.isEmpty()：判断集合中是否有元素，若有则返回true；若没有，则返回false</p></li></ul><p><strong>Set常用方法</strong></p><ul><li>add():添加元素</li><li>remove():从集合中删除指定的元素。</li><li>contains():判断集合中是否包含指定的元素。</li><li>isEmpty():判断集合是否为空。</li><li><code>size()</code>：返回集合中的元素数量。</li><li></li></ul><p><strong>Map常用方法</strong></p><ul><li><p>put(key,value);   添加、修改。</p></li><li><p>remove():删除指定 key 对应的键值对</p></li><li><p>-size();          返回元素的个数</p></li><li><p>-get(key);        根据键返回相关联的值，如果不存在指定的键，返回null</p></li><li><p>-keySet()         返回键的Set集合</p></li><li><p>values():       返回 Map 中所有 value 的集合</p></li><li><p>entrySet()        返回键值对的Set集合</p></li><li><p>containsKey和containsValue:用于判断 Map 中是否包含指定的 key 或 value 值</p></li><li><p>isEmpty(): 判断 Map 是否为空</p></li><li><p>clear(): 清空 Map 中所有的键值对</p></li></ul><h1 id="二、Java多线程"><a href="#二、Java多线程" class="headerlink" title="二、Java多线程"></a>二、Java多线程</h1><p id="3"></p><h1 id="三、JVM"><a href="#三、JVM" class="headerlink" title="三、JVM"></a>三、JVM</h1><p id="301"></p><h2 id="1、知识点汇总"><a href="#1、知识点汇总" class="headerlink" title="1、知识点汇总"></a>1、知识点汇总</h2><p>JVM是Java运行基础，面试时一定会遇到JVM有关问题，内容集中</p><p><img src="/2024/10/10/bagu/bagu6.png" alt="bagu6"></p><p><img src="/2024/10/10/bagu/bagu7.png" alt="bagu7"></p><p>其中内存模型，类加载机制，GC是重点方面。性能调优部分更偏向应用，重点突出实践能力。编译器优化和执行模式部分偏向于理论基础，重点掌握知识点。<br>需了解<strong>内存模型</strong>各部分作用，保存哪些数据.<br><strong>类加载</strong>双亲委派加载机制，常用加载器分别加载哪种类型的类.<br><strong>GC分代回收</strong>的思想和依据以及不同垃圾回收算法的回收思路和适合场景.<br><strong>性能调优常</strong>有JVM优化参数作用，参数调优的依据，常用的JVM分析工具能分析哪些问题以及使 用方法.<br><strong>执行模式</strong>解释&#x2F;编译&#x2F;混合模式的优缺点，Java7提供的分层编译技术，JIT即时编译技术，OSR栈上 替 换，C1&#x2F;C2 编译器针对的场景，C2针对的是server模式，优化更激进.新技术方面Java10的graal编译器<br><strong>编译器</strong>优化javac的编译过程，ast抽象语法树，编译器优化和运行器优化</p><p id="302"></p><h2 id="2、知识点详解"><a href="#2、知识点详解" class="headerlink" title="2、知识点详解"></a>2、知识点详解</h2><h3 id="1-JVM内存模型"><a href="#1-JVM内存模型" class="headerlink" title="1.JVM内存模型"></a>1.JVM内存模型</h3><p>线程独占：栈，本地方法栈，程序计数器 线程共享：堆，方法区</p><h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><p>又称方法栈，线程私有的，线程执行方法是会创建一个栈桢，用来存储局部变量表，操作栈，动态链接，方法出口等信息，调用方法时执行入栈，方法返回时执行出栈。</p><p id="4"></p><h1 id="四、Mysql"><a href="#四、Mysql" class="headerlink" title="四、Mysql"></a>四、Mysql</h1><h2 id="1、select语句完整的执行顺序"><a href="#1、select语句完整的执行顺序" class="headerlink" title="1、select语句完整的执行顺序"></a>1、select语句完整的执行顺序</h2><p>SQL Select 语句完整的执行顺序：</p><ol><li>from子句组装来自不同数据源的数据；</li><li>where子句基于指定的条件对记录进行筛选</li><li>group by 子句将数据划分为多个分组</li><li>使用聚集函数进行计算</li><li>使用having子句筛选分组</li><li>计算所有的表达式</li><li>select的字段</li><li>使用order by对结果集进行排序</li></ol><h2 id="2、MySQL事务"><a href="#2、MySQL事务" class="headerlink" title="2、MySQL事务"></a>2、MySQL事务</h2><p><strong>事务的基本要素（ACID）</strong></p><ul><li><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做， 不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的 操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原 子，是物质构成的基本单位。</li><li><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破 坏 。比如 A 向 B转账，不可能A扣了钱，B却没收到。</li><li><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务 之间彼此没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前， B 不能向这张卡转账。</li><li><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据 库，不能回滚。</li></ul><p><strong>MySQL事务隔离级别</strong></p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>事务的并发问题</strong></p><ul><li><strong>脏读：</strong>事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的 数据是脏数据</li><li><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程 中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致</li><li><strong>幻读：</strong>系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等 级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改 结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 如何解决脏读、幻读、不可重复读</li></ul><p><strong>如何解决脏读、幻读、不可重复读</strong></p><ul><li>脏读： 隔离级别为 读提交、可重复读、串行化可以解决脏读</li><li>不可重复读：隔离级别为可重复读、串行化可以解决不可重复读</li><li>幻读：隔离级别为串行化可以解决幻读、通过MVCC+区间锁可以解决幻读</li></ul><p><strong>小结：</strong></p><p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><h2 id="4、悲观锁和乐观锁怎么实现"><a href="#4、悲观锁和乐观锁怎么实现" class="headerlink" title="4、悲观锁和乐观锁怎么实现"></a>4、悲观锁和乐观锁怎么实现</h2><p id="6"></p><h1 id="五、Redis"><a href="#五、Redis" class="headerlink" title="五、Redis"></a>五、Redis</h1><h2 id="1、为什么要用缓存"><a href="#1、为什么要用缓存" class="headerlink" title="1、为什么要用缓存"></a>1、为什么要用缓存</h2><p>使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。Redis的读写性能比Mysql好得多，我们就可以把Mysql中的热点数据缓存到Redis中，提升读取性能，同时也减轻了Mysql的读取压力。</p><h2 id="2、说一下Redis有什么优点和缺点"><a href="#2、说一下Redis有什么优点和缺点" class="headerlink" title="2、说一下Redis有什么优点和缺点"></a>2、说一下Redis有什么优点和缺点</h2><p><strong>优点</strong></p><ul><li><strong>速度快：</strong>因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1);</li><li><strong>支持丰富的数据结构：</strong>支持String，List，Set，SortedSet，Hash五种基础的数据结构。</li><li><strong>持久化存储：</strong>Redis提供RDB和AOF两种数据的持久化存储方案，解决内存数据库最担心的万一Redis挂掉，数据会消失的问题。</li><li><strong>高可用：</strong>内置Redis，Sentinel，提供高可用方案，实现主从故障自动转移。内置Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模。</li><li><strong>丰富的特性：</strong>Key过期、计数、分布式锁、消息队列等。</li></ul><p><strong>缺点</strong></p><ul><li>由于Redis是内存数据库，所以，单台机器存储的数据量，跟机器本身的内存大小有关。虽然Redis本身有Key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据；</li><li>如果进行完整重同步，由于需要生成RDB文件，并进行传输，会占用主机的CPU，并会消耗网的带宽。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis不能提供服务。</li></ul><h2 id="3、什么是Redis"><a href="#3、什么是Redis" class="headerlink" title="3、什么是Redis"></a>3、什么是Redis</h2><p>Redis是一个开源、基于内存、支持多种数据结构的存储系统，可以作为数据库缓存和消息中间件。它支持的数据结构有字符串(Strings)、哈希(hashes)、列表(sets)、有序集合(sorted sets)等，除此之外还支持bitmaps\hyperlologs和地理空间(geospatial)索引半径查询等功能。</p><p>它内置了复制、LUA脚本、LRU驱动事件、事务和不同级别的磁盘持久化功能，并通过Redis哨兵和集群保证缓存的高可用性。</p><h2 id="4、为什么Redis单线程模型效率也能那么高"><a href="#4、为什么Redis单线程模型效率也能那么高" class="headerlink" title="4、为什么Redis单线程模型效率也能那么高"></a>4、为什么Redis单线程模型效率也能那么高</h2><ol><li>C语言实现，效率高；</li><li>纯内存操作；</li><li>基于非阻塞的IO复用模型机制；</li><li>单线程的话能避免多线程的频繁上下文切换问题；</li><li>丰富的数据结构(全程采用hash结构，读取速度非常快，对数据存储进行了一些优化)</li></ol><h2 id="5、说说Redis的线程模型-基于非阻塞的IO复用模型机制"><a href="#5、说说Redis的线程模型-基于非阻塞的IO复用模型机制" class="headerlink" title="5、说说Redis的线程模型(基于非阻塞的IO复用模型机制)"></a>5、说说Redis的线程模型(基于非阻塞的IO复用模型机制)</h2><p>Redis内部使用文件事件处理器(file event handler),这个文件事件处理器是单线程的，所以Redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含4部分：</p><ol><li>多个socket；</li><li>IO多路服用程序；</li><li>文件事件分派器；</li><li>事件处理器(连接应答处理器，命令请求处理器，命令回复处理器)</li></ol><p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><h2 id="6、为什么Redis需要把所有数据放到内存中？"><a href="#6、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="6、为什么Redis需要把所有数据放到内存中？"></a>6、为什么Redis需要把所有数据放到内存中？</h2><p>Redis将数据放在内存中有一个好处，那就是可以实现最快地对数据读取，如果数据存储在硬盘中，磁盘I&#x2F;O会严重影响Redis的性能。而且Redis还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，Redis的使用也被应用的越来越多，使得它拥有很大的优势。</p><h2 id="7、Redis的同步机制是什么"><a href="#7、Redis的同步机制是什么" class="headerlink" title="7、Redis的同步机制是什么"></a>7、Redis的同步机制是什么</h2><p>Redis支持主从同步、从同步。如果是第一次进行主从同步，主节点需要使用bgsave命令，再将后续修改操作记录到内存的缓冲区，等RDB文件全部同步到复制节点，复制节点接收完成后将RDB镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p><h2 id="8、Redis缓存刷新策略有哪些"><a href="#8、Redis缓存刷新策略有哪些" class="headerlink" title="8、Redis缓存刷新策略有哪些"></a>8、Redis缓存刷新策略有哪些</h2><p id="7"></p><h1 id="六、计算机网络系列"><a href="#六、计算机网络系列" class="headerlink" title="六、计算机网络系列"></a>六、计算机网络系列</h1><p id="8"></p><h1 id="七、linux"><a href="#七、linux" class="headerlink" title="七、linux"></a>七、linux</h1><h1 id="八、maven篇"><a href="#八、maven篇" class="headerlink" title="八、maven篇"></a>八、maven篇</h1><h2 id="1、什么是maven？"><a href="#1、什么是maven？" class="headerlink" title="1、什么是maven？"></a>1、什么是maven？</h2><p>maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。</p><p>maven项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统和用来运行定义在生命周期阶段中插件目标的逻辑。当使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的插件。</p><h2 id="2、maven能为我们解决什么问题"><a href="#2、maven能为我们解决什么问题" class="headerlink" title="2、maven能为我们解决什么问题"></a>2、maven能为我们解决什么问题</h2><ol><li><p><strong>添加第三方jar包</strong></p><p>按照最原始的做法，我们是手动复制jar包到项目WEB-INF&#x2F;lib下，每个项目都会有一份，造成 大量 重复文件。<strong>而Maven将jar包放在本地仓库中统一管理，需要jar包只需要用坐标的方式引用即可。</strong></p></li><li><p><strong>jar包之间的依赖关系</strong></p><p>jar 包之间往往不是独立的，很多jar需要在其他jar包的支持下才能够正常工作，称为jar包之 间的依 赖关系。如果我们手动去导入，要知道jar包之间的依赖关系并一一导入是极其麻烦而且 容易出错 的。<strong>如果使用Maven，它能够将当前jar包所依赖的其他所有jar包全部导入。</strong></p></li><li><p><strong>获取第三方jar包</strong></p><p>开发过程中我们需要用到很多jar包，每个jar包在官网获取的方式不尽相同，给工作带来了额外困难。<strong>但是使用Maven可以以坐标的方式依赖一个jar包，Maven从中央仓库进行下载，并同时下载这 个jar包依赖的其他jar包。</strong></p></li><li><p><strong>将项目拆分为多个工程模块</strong></p><p>项目的规模越来越大，已经不可能通过package结构来划分模块，必须将项目拆分为多个工程协同开发。</p></li></ol><h2 id="3、说说maven有什么优缺点"><a href="#3、说说maven有什么优缺点" class="headerlink" title="3、说说maven有什么优缺点"></a>3、说说maven有什么优缺点</h2><p><strong>优点：</strong></p><ul><li>简化了项目依赖管理</li><li>易于上手，对于新手来说了解几个常用命令即可满足日常工作；</li><li>便于与持续集成工具(jenkins)整合；</li><li>便于项目升级，无论是项目本身还是项目使用的依赖；</li><li>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等；</li></ul><p><strong>缺点：</strong></p><ul><li>Maven是一个庞大的构建系统，学习难度大；入门容易精通难；</li><li>Maven采用约定由于配置的策略，虽然上手容易但是一旦出现问题，难于调试中网络环境较差，很多repository无法访问。</li></ul><h2 id="4、什么是maven坐标"><a href="#4、什么是maven坐标" class="headerlink" title="4、什么是maven坐标"></a>4、什么是maven坐标</h2><p>Maven 其中一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化地解析任何一个Java构件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包括我们自己开发的项目，也是要通过坐标进行唯一 标识的，这样 才能在其他项目中进行依赖引用。</p><p>maven的坐标通过groupId，artifactId，version唯一标志一个构件。groupId通常为公司或组织名字，artifactId通常为项目名称，version为版本号。</p><h2 id="5、讲一下maven的生命周期"><a href="#5、讲一下maven的生命周期" class="headerlink" title="5、讲一下maven的生命周期"></a>5、讲一下maven的生命周期</h2><p>Maven的生命周期：从我们的项目构建，一直到项目发布的这个过程。</p><p><img src="/2024/10/10/bagu/bagu3.png" alt="bagu3"></p><p>每个阶段的说明：</p><table><thead><tr><th>阶段</th><th>处理</th><th>描述</th></tr></thead><tbody><tr><td>validate</td><td>验证项目</td><td>验证项目是否正确且所有必须信息是可用的</td></tr><tr><td>compile</td><td>执行编译</td><td>源代码编译在此阶段完成</td></tr><tr><td>test</td><td>测试</td><td>使用适当的单元测试框架(Unit)运行测试</td></tr><tr><td>package</td><td>打包</td><td>创建JAR&#x2F;WAR包如在pom.xml中定义提及的包</td></tr><tr><td>verify</td><td>检查</td><td>对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td>install</td><td>安装</td><td>安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td>deploy</td><td>部署</td><td>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><h2 id="6、说说你熟悉哪些maven命令"><a href="#6、说说你熟悉哪些maven命令" class="headerlink" title="6、说说你熟悉哪些maven命令"></a>6、说说你熟悉哪些maven命令</h2><p>mvn archetype:generate 创建 Maven项目</p><p>mvn compile 编译源代码 </p><p>mvn deploy 发布项目 </p><p>mvn test-compile 编译测试源代码 </p><p>mvn test 运行应用程序中的单元测试 </p><p>mvn site 生成项目相关信息的网站 </p><p>mvn clean 清除项目目录中的生成结果 </p><p>mvn package 根据项目生成的jar </p><p>mvn install 在本地 Repository中安装 jar </p><p>mvn eclipse:eclipse 生成 eclipse 项目文件 </p><p>mvnjetty :run 启动 jetty 服务 </p><p>mvntomcat :run 启动 tomcat服务 </p><p>mvn clean package-Dmaven.test.skip&#x3D;true：清除以前的包后重新打包，跳过测试类</p><h2 id="7、如何解决以来传递引起的版本冲突"><a href="#7、如何解决以来传递引起的版本冲突" class="headerlink" title="7、如何解决以来传递引起的版本冲突"></a>7、如何解决以来传递引起的版本冲突</h2><p>可通过dependency的exclusion元素排除掉依赖。</p><h2 id="8、说说maven的依赖原则"><a href="#8、说说maven的依赖原则" class="headerlink" title="8、说说maven的依赖原则"></a>8、说说maven的依赖原则</h2><ul><li>最短路径原则(依赖传递的路径越短越优先)；</li><li>pom文件申明顺序优先(路径长度一样，则先声明的优先)；</li><li>覆写原则(当前pom文件里声明的直接覆盖父工程传过来的)。</li></ul><h2 id="10、说说依赖的解析机制"><a href="#10、说说依赖的解析机制" class="headerlink" title="10、说说依赖的解析机制"></a>10、说说依赖的解析机制</h2><p>当依赖的范围是 system 的时候，Maven 直接从本地文件系统中解析构件。 根据依赖坐标计算仓库路径，尝试直接从本地仓库寻找构件，如果发现对应的构件，就解析成功。 如果在本地仓库不存在相应的构件，就遍历所有的远程仓库，发现后，下载并解析使用。 </p><p>如果依赖的版本是 RELEASE 或 LATEST，就基于更新策略读取所有远程仓库的元数据文 件 （ groupId&#x2F;artifactId&#x2F;maven-metadata.xml），将其与本地仓库的对应元合并后， 计算出 RELEASE 或者 LATEST 真实的值，然后基于该值检查本地仓库，或者从远程仓库 下载。 </p><p>如果依赖的版本是 SNAPSHOT，就基于更新策略读取所有远程仓库的元数据文件，将它与本地仓 库 对应的元数据合并，得到最新快照版本的值，然后根据该值检查本地仓库，或从远程仓库下载。 </p><p>如果最后解析得到的构件版本包含有时间戳，先将该文件下载下来，再将文件名中时间戳信息 删 除，剩下 SNAPSHOT 并使用（以非时间戳的形式使用）。</p><h2 id="11、说说插件的解析机制"><a href="#11、说说插件的解析机制" class="headerlink" title="11、说说插件的解析机制"></a>11、说说插件的解析机制</h2><p>与依赖的构件一样，插件也是基于坐标保存在Maven仓库中。在用到插件的时候会先从本地仓库 查 找插件，如果本地仓库没有则从远程仓库查找插件并下载到本地仓库。与普通的依赖构件不同 的 是，Maven会区别对待普通依赖的远程仓库与插件的远程仓库。前面提到的配置远程仓库只会对 普 通的依赖有效果。当Maven需要的插件在本地仓库不存在时是不会去我们以前配置的远程仓 库查找 插件的，而是需要有专门的插件远程仓库。</p><h1 id="九、Java框架"><a href="#九、Java框架" class="headerlink" title="九、Java框架"></a>九、Java框架</h1><h2 id="1、什么是Spirng"><a href="#1、什么是Spirng" class="headerlink" title="1、什么是Spirng"></a>1、什么是Spirng</h2><p>Spring时个java企业级应用的开源开发框架。Spirng主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架目标是简化java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p><h2 id="2、为什么使用Spring框架"><a href="#2、为什么使用Spring框架" class="headerlink" title="2、为什么使用Spring框架"></a>2、为什么使用Spring框架</h2><ul><li><strong>轻量：</strong>Spring是轻量的，基本的版本大约2MB</li><li><strong>控制反转</strong>(IOC)：Spring通过控制反转实现了松散耦合，对象们给出他们的依赖，而不是创建或查找依赖的对象们。</li><li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器</strong>：Spring包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC框架</strong>：Spring的WEB框架是一个精心设计的框架，是Web框架的一个很好的替代品。</li><li><strong>事务管理：</strong>Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务。</li><li><strong>异常处理</strong>：Spring提供方便的API把具体技术相关的异常(如JDBC,Hibernate or JDO 抛出的)转化为一致的unchecked异常</li></ul><h2 id="3、Autowired和Resource关键字的区别"><a href="#3、Autowired和Resource关键字的区别" class="headerlink" title="3、Autowired和Resource关键字的区别"></a>3、Autowired和Resource关键字的区别</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><ol><li><p>共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p></li><li><p>不同点</p><ol><li><p>@Autowired</p><p>@Autowired 为 Spring 提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line"><span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Autowired注解是按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称(byName)来装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</p><p>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果不指定name，也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Resource只要使用一种即可</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的 setter方法</span></span><br><span class="line">上 <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p><p>@Resource装配顺序：</p><ol><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常；</li><li>如果指定了name，则从上下文查找名称匹配的bean进行装配，找不到则抛出异常；</li><li>如果指定了type，则从上下文查找匹配的唯一bean进行装配，找不到或者找到多个，则抛出异常；</li><li>如果既没有指定name，有没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ol><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p></li></ol></li></ol><h2 id="4、依赖注入的方式有几种，各是什么？"><a href="#4、依赖注入的方式有几种，各是什么？" class="headerlink" title="4、依赖注入的方式有几种，各是什么？"></a>4、<strong>依赖注入的方式有几种，各是什么？</strong></h2><p><strong>一、构造器注入将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</strong></p><ul><li>优点：对象初始化完成后便可获得可使用的对象；</li><li>缺点：当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定的几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li></ul><p><strong>二、setter方法注入IOCservice Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。</strong></p><ul><li>优点：灵活。可以选择地注入需要的对象；</li><li>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</li></ul><p><strong>三、接口注入依赖类必须实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。</strong></p><ul><li>优点：接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。</li><li>缺点：侵入性太强，不建议使用。</li></ul><h2 id="5、讲一下Spring是什么"><a href="#5、讲一下Spring是什么" class="headerlink" title="5、讲一下Spring是什么"></a>5、讲一下Spring是什么</h2><p>Spring是一个轻量级的IOC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需要。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p><p>主要有以下几个模块组成：</p><ul><li><strong>Spring Core：</strong>核心类库，提供IOC服务</li><li>**Spring Context:**提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）</li><li><strong>Spring AOP:</strong></li><li>**Spring DAO:**对JDBC的抽象，简化了数据访问异常的处理</li><li>**Spring ORM:**对现有的ORM框架的支持</li><li>**Spring Web:**提供了基本的面向Web的综合特征，例如多方文件上传</li><li>**Spring MVC:**提供面向Web应用的Model-View-Controller实现</li></ul><p><strong>Spring容器的主要核心</strong></p><ul><li><strong>控制反转(IOC)</strong>,传统的java开发模式中，当需要一个对象时，我们会自己使用 new 或者getInstance 等直接或者间接调用构造方法创建一个对象。而在spring开发 模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创 建了，直接调用 spring提供的对象就可以了，这是控制反转的思想。</li><li>**依赖注入(DI)**，spring 使用javaBean 对象的 set 方法或者带参数的构造方法为我们 在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</li><li>**面向切面编程(AOP),**在面向对象编程（oop）思想中，我们将事物纵向抽成一个个 的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切 面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就 是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果 是类采用 CGLIB方式实现动态代理。</li></ul><h2 id="6、说说你对Spring-MVC的理解"><a href="#6、说说你对Spring-MVC的理解" class="headerlink" title="6、说说你对Spring MVC的理解"></a>6、说说你对Spring MVC的理解</h2><p><strong>一、什么是MVC模式</strong></p><p>MVC：MVC是一种设计模式</p><p>MVC的原理图：</p><p><img src="/2024/10/10/bagu/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241011172113.png" alt="微信截图_20241011172113"></p><p><strong>分析：</strong></p><p>M-Model模型（完成业务逻辑：由javaBean构成，service+dao+entity）</p><p>V-View视图（做界面的展示jsp，html）</p><p>C-Controller控制器</p><p>springMVC是Spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单地把springMVC理解为是spring的一个模块。</p><p><strong>二、SpringMVC的工作流程：</strong></p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li><li>处理器映射器找到具体的处理器,生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器</li><li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li><li>Controller执行完成ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet根据View进行渲染视图</li><li>DispatcherServlet响应用户</li></ol><p><strong>三、SpringMVC如何返回JSON数据</strong></p><ol><li>在项目中加入json转换的依赖，例如jackson，fastjson，gson等</li><li>在请求处理方法中将返回值改为具体返回的数据的类型，例如数据的集合类List<Employee></Employee></li><li>在请求处理方法上使用@ResponseBody注解</li></ol><h2 id="7、说出Spring或者SpringMVC常用的五个注解"><a href="#7、说出Spring或者SpringMVC常用的五个注解" class="headerlink" title="7、说出Spring或者SpringMVC常用的五个注解"></a>7、说出Spring或者SpringMVC常用的五个注解</h2><ul><li>@Component 基本注解，标识一个受Spring管理的组件</li><li>@Controller                        标识为一个表示层的组件</li><li>@Service                              标识为一个业务层的组件</li><li>@Repository                        标识为一个持久层的组件</li><li>@Autowired                          自动装配</li><li>@Qualifier(“”)                       具体指定要装配的组件的id值</li><li>@RequestMapping()            完成请求映射</li><li>@PathVariable                      映射请求URL中占位符到请求处理方法的形参</li></ul><h2 id="8、Spring中常用的设计模式"><a href="#8、Spring中常用的设计模式" class="headerlink" title="8、Spring中常用的设计模式"></a>8、Spring中常用的设计模式</h2><ol><li>代理模式——spring中两种代理方式，若目标对象实现了若干接口，spring使用jdk的java.lang.reflect.Proxy类代理。若目标兑现没有实现任何接口，spring使用CGLIB库生成目标类的子类。</li><li>单例模式——在spring的配置文件中设置bean默认为单例模式。</li><li>模块方式模式——用来解决代码重复的问题。</li><li>比如：RestTemplate、JmsTemplate、JpaTemplate</li><li>工厂模式——在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用同一个接口来指向新创建的对象。Spring中使用beanFactory来创建对象的实例。</li></ol><h2 id="9、Spring-bean-的生命周期、注入方式和作用域"><a href="#9、Spring-bean-的生命周期、注入方式和作用域" class="headerlink" title="9、Spring bean 的生命周期、注入方式和作用域"></a>9、Spring bean 的生命周期、注入方式和作用域</h2><p><strong>Bean的生命周期</strong></p><ol><li>默认情况下，IOC容器中bean的生命周期分为五个阶段：<ul><li>调用构造器或者是通过工厂的方式创建Bean对象</li><li>给bean对象的属性注入值</li><li>调用初始化方法，进行初始化，初始化方法是通过init-method来指定的</li><li>使用</li><li>IOC容器关闭时，销毁Bean对象</li></ul></li><li>当加入Bean的后置处理器后，IOC容器中的bean的生命周期分为七个阶段：<ul><li>调用构造器或者通过工厂的方式创建Bean对象</li><li>给bean对象的属性注入值</li><li>执行Bean后置处理器中的postProcessBeforeInitialization</li><li>调用初始化方法，进行初始化，初始化方法是通过init-method来指定的</li><li>执行Bean的后置处理器中postProcessAfterInitialization</li><li>使用</li><li>IOC容器关闭时，销毁Bean对象</li></ul></li></ol><p><strong>注入方式</strong></p><p>通过setter方法注入</p><p>通过构造方法注入</p><p><strong>Bean的作用域</strong></p><ol><li>Singleton 单例的</li><li>Prototype 原型的</li><li>Request</li><li>Seesion</li></ol><h2 id="10、请描述一下Spring事务管理"><a href="#10、请描述一下Spring事务管理" class="headerlink" title="10、请描述一下Spring事务管理"></a>10、请描述一下Spring事务管理</h2><p>（1）声明式事务管理的定义：用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。这样的好处是，事务管理部侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可，这样维护起来极其方便。</p><p>基于TransactionInterceptor的声明式事务管理：两个次要的属性：</p><p>transactionManager，用来指定一个事务治理器，并将具体事务相关的操作请托给它；</p><p>其他一个是Properties类型的transactionAttributes属性，该属性的每一个键值对中，键指定的是方法名，方法名可以行使通配符，而值就是表现呼应方法的所运用的事务属性。</p><p>（2）基于@Transactional的声明式事务管理：Spring2.x还引入基于Annotation的体式格式，具体要触及@Transactional标注。@Transactional可以浸染于接口、接口方法、类和类方法上。算作用于类上时，该类的一切public方法将都具有该类型的事务属性。</p><p>（3）编程式事务管理的定义：在代码中显示挪用beginTransaction（）、commit（）、rollback（）等事务治理相关的方法，这就是编程式事务管理。Spring对事物的编程式管理有基于底层API的编程式管理和基于TransactionTemplate的编程式事务管理两种方式。</p><h2 id="11、Mybatis中-和-区别是什么"><a href="#11、Mybatis中-和-区别是什么" class="headerlink" title="11、Mybatis中#{}和${}区别是什么"></a>11、Mybatis中#{}和${}区别是什么</h2><p>#{}是预编译处理，${}是字符串替换；</p><p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；</p><p> Mybatis 在处理${}时，就是把它替换成变量的值；</p><p> 使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p><h2 id="12、Mybatis如何获取自动生成的主键值"><a href="#12、Mybatis如何获取自动生成的主键值" class="headerlink" title="12、Mybatis如何获取自动生成的主键值"></a>12、Mybatis如何获取自动生成的主键值</h2><p>在标签中使用 useGeneratedKeys 和 keyProperty 两个属性来获取自动生成的 主键值。 示例: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert id=”insertname” usegeneratedkeys=”<span class="literal">true</span>” keyproperty=”id”&gt;</span><br><span class="line">insert into <span class="title function_">names</span> <span class="params">(name)</span> values (#&#123;name&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h2 id="13、简述Mybatis的动态sql，列出常用的六个标签及作用"><a href="#13、简述Mybatis的动态sql，列出常用的六个标签及作用" class="headerlink" title="13、简述Mybatis的动态sql，列出常用的六个标签及作用"></a>13、简述Mybatis的动态sql，列出常用的六个标签及作用</h2><p>动态 SQL 是 MyBatis 的强大特性之一 基于功能强大的 OGNL 表达式。 </p><p>动态 SQL 主要是来解决查询条件不确定的情况，在程序运行期间，根据提交的条件动 态的完成查询 </p><p>常用的标签: </p><p><if>: 进行条件的判断</if></p><p><where>：在判断后的 SQL 语句前面添加 WHERE 关键字，并处理 SQL 语句开 始位置的 AND 或者 OR 的问题</where></p><p> <trim>：可以在 SQL 语句前后进行添加指定字符 或者去掉指定字符. </trim></p><p><set>: 主要用于修改操作时出现的逗号问题  </set></p><p><choose>：类似于 java 中的 switch 语句.在所有的条件中选 择其一 </choose></p><p><foreach>：迭代操作</foreach></p><h2 id="13、Mybatis-如何完成-MySQL的批量操作"><a href="#13、Mybatis-如何完成-MySQL的批量操作" class="headerlink" title="13、Mybatis 如何完成 MySQL的批量操作"></a>13、Mybatis 如何完成 MySQL的批量操作</h2><p>MyBatis 完成 MySQL 的批量操作主要是通过标签来拼装相应的 SQL 语句 </p><p>例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert** id=<span class="string">&quot;insertBatch&quot;</span> &gt;</span><br><span class="line">insert into <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,d_id)</span> values</span><br><span class="line">&lt;foreach** collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;curr_emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>**&gt;</span><br><span class="line">(#&#123;curr_emp.lastName&#125;,#&#123;curr_emp.email&#125;,#&#123;curr_emp.gender&#125;,#&#123;curr_emp.dept.id&#125;</span><br><span class="line">)</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;`</span><br></pre></td></tr></table></figure><h2 id="14、谈谈怎么理解SpringBoot框架"><a href="#14、谈谈怎么理解SpringBoot框架" class="headerlink" title="14、谈谈怎么理解SpringBoot框架"></a>14、谈谈怎么理解SpringBoot框架</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是 简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上 手。</p><p><img src="/2024/10/10/bagu/image-20241105154012436.png" alt="image-20241105154012436"></p><p><strong>Spring Boot的优点</strong> </p><ul><li><p>独立运行 </p><p>Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成 war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依 赖包都在一个 jar 包内。</p></li><li><p>简化配置</p></li></ul><p>  spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置。除此之 外，还提供了各种启动器，开发者能快速上手。</p><ul><li>自动配置</li></ul><p>  Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring- boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。</p><ul><li>无代码生成和 XML 配置</li></ul><p>  Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作， 这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。</p><ul><li>应用监控</li></ul><p>  Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p><p> <strong>Spring Boot缺点：</strong> </p><p>Spring Boot 虽然上手很容易，但如果你不了解其核心技术及流程，所以一旦遇到问题 就很棘手，而且现在的解决方案也不是很多，需要一个完善的过程。</p><h2 id="15、Spring-Boot-的核心注解是哪个-它主要由哪几个注解-组成的"><a href="#15、Spring-Boot-的核心注解是哪个-它主要由哪几个注解-组成的" class="headerlink" title="15、Spring Boot 的核心注解是哪个 它主要由哪几个注解 组成的"></a>15、Spring Boot 的核心注解是哪个 它主要由哪几个注解 组成的</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要 组合包含了以下 3 个注解：</p><ul><li><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功 能。 </p></li><li><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置 的选项， </p><p>如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。 </p></li><li><p>@ComponentScan：Spring 组件扫描</p></li></ul><h2 id="16、Spring-Boot自动配置原理是什么"><a href="#16、Spring-Boot自动配置原理是什么" class="headerlink" title="16、Spring Boot自动配置原理是什么"></a>16、Spring Boot自动配置原理是什么</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配 置的核心， </p><p>首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。 @EnableAutoConfiguration 是实现自动配置的注解 </p><p>@Configuration 表示这是一个配置文件 </p><p>具体参考文档：</p><p>[<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484365&idx=1">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484365&amp;idx=1</a> &amp;sn&#x3D;a4ab1d977d6b03bf122b4d596d7ee1ab&amp;scene&#x3D;21](<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484365&idx=1">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484365&amp;idx=1</a><br>&amp;sn&#x3D;a4ab1d977d6b03bf122b4d596d7ee1ab&amp;scene&#x3D;21)</p><h2 id="17、SpringBoot和-SpringCloud是什么关系"><a href="#17、SpringBoot和-SpringCloud是什么关系" class="headerlink" title="17、SpringBoot和 SpringCloud是什么关系"></a>17、SpringBoot和 SpringCloud是什么关系</h2><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个 微服务，Spring Cloud 是一个基于 Spring Boot 实现的开发工具；Spring Boot 专注于 快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架； Spring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配 置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现，必须基于 Spring Boot 开 发。 </p><p>可以单独使用 Spring Boot 开发项目，但是 Spring Cloud 离不开 Spring Boot。</p><h2 id="18、SpringCloud都用过哪些组件-介绍一下作用"><a href="#18、SpringCloud都用过哪些组件-介绍一下作用" class="headerlink" title="18、SpringCloud都用过哪些组件 介绍一下作用"></a>18、SpringCloud都用过哪些组件 介绍一下作用</h2><ul><li>(1) Nacos–作为注册中心和配置中心，实现服务注册发现和服务健康监测及配置信息 统一管理 </li><li>(2) Gateway–作为网关，作为分布式系统统一的出入口，进行服务路由，统一鉴权等</li><li>(3) OpenFeign–作为远程调用的客户端，实现服务之间的远程调用 </li><li>(4) Sentinel–实现系统的熔断限流</li><li>(5) Sleuth–实现服务的链路追踪</li></ul><h2 id="19、Nacos作用以及注册中心的原理"><a href="#19、Nacos作用以及注册中心的原理" class="headerlink" title="19、Nacos作用以及注册中心的原理"></a>19、Nacos作用以及注册中心的原理</h2><p>Nacos 英文全称 Dynamic Naming and Configuration Service，Na 为 naming&#x2F;nameServer 即注册中心,co 为 configuration 即注册中心，service 是指该注册 &#x2F;配置中心都是以服务为核心。 </p><p>Nacos 注册中心分为 server 与 client，server 采用 Java 编写，为 client 提供注册发 现服务与配置服务。而 client 可以用多语言实现，client 与微服务嵌套在一起，nacos 提供 sdk 和 openApi，如果没有 sdk 也可以根据 openApi 手动写服务注册与发现和配 置拉取的逻辑。</p><p><img src="/2024/10/10/bagu/image-20241112184133630.png" alt="image-20241112184133630"></p><p><strong>服务注册原理</strong></p><p>服务注册方法：以 Java nacos client v1.0.1 为例子，服务注册的策略的是每 5 秒向 nacos server 发送一次心跳，心跳带上了服务名，服务 ip，服务端口等信息。同时 nacos server 也会向 client 主动发起健康检查，支持 tcp&#x2F;http 检查。如果 15 秒内无 心跳且健康检查失败则认为实例不健康，如果 30 秒内健康检查失败则剔除实例。</p><p><img src="/2024/10/10/bagu/image-20241112184253717.png" alt="image-20241112184253717"></p><h2 id="20、Feign工作原理"><a href="#20、Feign工作原理" class="headerlink" title="20、Feign工作原理"></a>20、Feign工作原理</h2><p>主程序入口添加了@EnableFeignClients 注解开启对 FeignClient 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加@FeignClient 注解。当程序启动时，会进行包扫 描，扫描所有@FeignClient 的注解的类，并且讲这些信息注入 Spring IOC 容器中，当定义 的的 Feign 接口中的方法被调用时，通过 JDK 的代理方式，来生成具体的 RequestTemplate. 当生成代理时，Feign 会为每个接口方法创建一个 RequestTemplate 对象，该对象封装 HTTP 请求需要的全部信息，如请求参数名，请求方法等信息都是在这个过程中确定的。 然后 RequestTemplate 生成 Request,然后把 Request 交给 Client 去处理，这里指的时 Client 可以时 JDK 原生的 URLConnection,Apache 的 HttpClient,也可以时 OKhttp，最后 Client 被封装到 LoadBalanceClient 类，这个类结合 Ribbon 负载均衡发器服务之间的调 用。</p><img src="/2024/10/10/bagu/image-20241112184501662.png" alt="image-20241112184501662" style="zoom:50%;"><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hmdp</title>
      <link href="/2024/09/30/hmdp/"/>
      <url>/2024/09/30/hmdp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="了解Cookie和Session的区别"><a href="#了解Cookie和Session的区别" class="headerlink" title="了解Cookie和Session的区别"></a>了解Cookie和Session的区别</h2><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>按照视频介绍导入需要的后端代码以及数据库<br>        更改数据库和redis的地址</p><h2 id="一、基于Session实现登录"><a href="#一、基于Session实现登录" class="headerlink" title="一、基于Session实现登录"></a>一、基于Session实现登录</h2><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240728162557.png" alt="微信图片_20240728162557"></p><h3 id="1-1-发送短信验证码"><a href="#1-1-发送短信验证码" class="headerlink" title="1.1 发送短信验证码"></a>1.1 发送短信验证码</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240728162811.png" alt="微信图片_20240728162811"></p><p><strong>请求为：post  $~~~$url:&#x2F;user&#x2F;code   $~~~$参数：phone</strong><br><strong>在usercontroller中生成方法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 发送手机验证码</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;code&quot;)</span><br><span class="line">public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123;</span><br><span class="line">    // 发送短信验证码并保存验证码</span><br><span class="line">    return userService.sendCode(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务代码</strong></p><blockquote><p>1.校验手机号<br>2.如果不符合，返回错误信息<br>3.符合，生成验证码<br>4.保存验证码到session<br>5.发送验证码<br>6.返回ok  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result sendCode(String phone, HttpSession session) &#123;</span><br><span class="line">    // 1.校验手机号</span><br><span class="line">    if (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        // 2.如果不符合，返回错误信息</span><br><span class="line">        return Result.fail(&quot;手机号格式错误！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.符合，生成验证码</span><br><span class="line">    String code = RandomUtil.randomNumbers(6);</span><br><span class="line"></span><br><span class="line">    // 4.保存验证码到 session</span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    // 5.发送验证码(模拟发送验证码)</span><br><span class="line">    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);</span><br><span class="line">    // 返回ok</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-短信验证码登录"><a href="#1-2-短信验证码登录" class="headerlink" title="1.2 短信验证码登录"></a>1.2 短信验证码登录</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240728164739.png" alt="微信图片_20240728164739"></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240728165019.png" alt="微信图片_20240728165019"></p><p><strong>请求为：post $~~~$ url:&#x2F;user&#x2F;login$~~~$ 参数为json形式：code和phone</strong>   </p><p><strong>封装登陆信息</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class LoginFormDTO &#123;</span><br><span class="line">    private String phone;</span><br><span class="line">    private String code;</span><br><span class="line">    private String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在usercontroller中生成方法</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录功能</span><br><span class="line"> * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span><br><span class="line"> */</span><br><span class="line">@PostMapping(&quot;/login&quot;)</span><br><span class="line">public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123;</span><br><span class="line">    // 实现登录功能</span><br><span class="line">    return userService.login(loginForm, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为参数为json数据，所以要加 <em><strong>@RequstBody</strong></em></p><p><strong>业务代码</strong></p><blockquote><p>1.校验手机号<br>2.校验验证码<br>3.不一致，报错<br>4.一致，根据手机号查用户<br>5.判断用户是否存在<br>6.不存在，创建新用户并保存<br>7.保存用户信息到session中  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result login(LoginFormDTO loginForm, HttpSession session) &#123;</span><br><span class="line">    // 1.校验手机号</span><br><span class="line">    String phone = loginForm.getPhone();</span><br><span class="line">    if (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        // 2.如果不符合，返回错误信息</span><br><span class="line">        return Result.fail(&quot;手机号格式错误！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.从redis获取验证码并校验</span><br><span class="line">    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    String code = loginForm.getCode();</span><br><span class="line">    if (cacheCode == null || !cacheCode.equals(code)) &#123;</span><br><span class="line">        // 不一致，报错</span><br><span class="line">        return Result.fail(&quot;验证码错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span><br><span class="line">    User user = query().eq(&quot;phone&quot;, phone).one();</span><br><span class="line"></span><br><span class="line">    // 5.判断用户是否存在</span><br><span class="line">    if (user == null) &#123;</span><br><span class="line">        // 6.不存在，创建新用户并保存</span><br><span class="line">        user = createUserWithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line">// 7.保存用户信息到 session中</span><br><span class="line">     session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user,UserDTO.class));</span><br><span class="line">     return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code> session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user,UserDTO.class));</code>     </li><li>将User的属性拷贝到UserDTO中，优点是不用新建对象</li></ul><h3 id="1-3检验登陆状态"><a href="#1-3检验登陆状态" class="headerlink" title="1.3检验登陆状态"></a>1.3检验登陆状态</h3><h4 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">//前置拦截</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        // 1.获取session</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        //2.获取session中的用户</span><br><span class="line">        Object user = session.getAttribute(&quot;user&quot;);</span><br><span class="line">        //3.判断用户是否存在</span><br><span class="line">        if(user == null) &#123;</span><br><span class="line">            //4.不存在，拦截</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //5.存在，保存用户信息在ThreadLocal</span><br><span class="line">        UserHolder.saveUser((UserDTO) user);</span><br><span class="line">        //6.放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">//后置拦截</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">       //移除用户</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置拦截器生效"><a href="#配置拦截器生效" class="headerlink" title="配置拦截器生效"></a>配置拦截器生效</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        &quot;/user/code&quot;,</span><br><span class="line">                        &quot;/user/login&quot;,</span><br><span class="line">                        &quot;/voucher/**&quot;,//优惠券查询</span><br><span class="line">                        &quot;/shop/**&quot;,//商店</span><br><span class="line">                        &quot;/shop-type/**&quot;,//商店类型</span><br><span class="line">                        &quot;/upload/**&quot;,//更新</span><br><span class="line">                        &quot;/blog/hot&quot;//博客热点</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4集群session共享问题"><a href="#1-4集群session共享问题" class="headerlink" title="1.4集群session共享问题"></a>1.4集群session共享问题</h3><p><em><strong>Session共享问题：</strong></em> 多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题<br>核心思路分析</p><ul><li>早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</li></ul><p>但是这种方案具有两个大问题</p><ul><li>每台服务器中都有完整的一份session数据，服务器压力过大。</li><li>ression拷贝数据时，可能会出现延迟  </li><li>所以后来采用的方案都是基于redis来完成，把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</li></ul><p><strong>session的替代方案应该满足：数据共享、内存存储、key、value结构。  即：Redis</strong></p><h3 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a>基于Redis实现共享session登录</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729103344.png" alt="微信图片_20240729103344"></p><blockquote><p>不能使用手机号做key，容易泄露，我们用token</p></blockquote><h4 id><a href="#" class="headerlink" title></a></h4><ul><li>保存登录的用户信息，可以使用String结构，以JSON字符串来保存，比较直观</li><li>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</li></ul><p><strong>这里我们选择hash</strong></p><p><strong>发送短信业务代码</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result sendCode(String phone, HttpSession session) &#123;</span><br><span class="line">    // 1.校验手机号</span><br><span class="line">    if (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        // 2.如果不符合，返回错误信息</span><br><span class="line">        return Result.fail(&quot;手机号格式错误！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.符合，生成验证码</span><br><span class="line">    String code = RandomUtil.randomNumbers(6);</span><br><span class="line"></span><br><span class="line">    // 4.保存验证码到 Redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    // 5.发送验证码</span><br><span class="line">    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);</span><br><span class="line">    // 返回ok</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>登录校验</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Result sendCode(String phone, HttpSession session) &#123;</span><br><span class="line">    // 1.校验手机号</span><br><span class="line">    if (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">        // 2.如果不符合，返回错误信息</span><br><span class="line">        return Result.fail(&quot;手机号格式错误！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 3.符合，生成验证码</span><br><span class="line">    String code = RandomUtil.randomNumbers(6);</span><br><span class="line"></span><br><span class="line">    // 4.保存验证码到 Redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    // 5.发送验证码</span><br><span class="line">    log.debug(&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;, code);</span><br><span class="line">    // 返回ok</span><br><span class="line">    return Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="登录状态续期"><a href="#登录状态续期" class="headerlink" title="登录状态续期"></a>登录状态续期</h4><ul><li><p>需求：用户session的过期时间不是固定的，如果期间内用户有访问系统，就应该给过期时间续期</p></li><li><p>由于自定义拦截器中没有注入容器，所以无法自动注入redis操作类，只能手动注入</p></li><li><p>可以通过构造方法注入，由于MvcConfig是配置类，由IoC容器管理，所以可以自动注入StringRedisTemplate对象，并将该对象通过构造器注入到自定义拦截器中</p></li><li></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoginInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        // 1.获取请求头中的token</span><br><span class="line">        String token = request.getHeader(&quot;authorization&quot;);</span><br><span class="line">        //判空</span><br><span class="line">        if (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            //不存在，拦截，返回401</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //2.基于TOKEN获取redis中的用户</span><br><span class="line">        String key =RedisConstants.LOGIN_USER_KEY+token;</span><br><span class="line">        Map&lt;Object, Object&gt; UserMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        //3.判断用户是否存在</span><br><span class="line">        if(UserMap.isEmpty()) &#123;</span><br><span class="line">            //4.不存在，拦截</span><br><span class="line">            response.setStatus(401);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //5.将hash转为user对象</span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(UserMap, new UserDTO(), false);</span><br><span class="line">        //6.存在，保存用户信息在ThreadLocal</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        //7.刷新token有效期</span><br><span class="line">        stringRedisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        //8.放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="登录报错数据类型转换错误"><a href="#登录报错数据类型转换错误" class="headerlink" title="登录报错数据类型转换错误"></a>登录报错数据类型转换错误</h4><ul><li>原因：使用StringRedisTemplate要求存储的数据类型都为String，因此要确保hash中的每一个值都为String类型</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 7.2.将User对象转为HashMap存储</span><br><span class="line">UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,new HashMap&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(true)//设置忽略null值</span><br><span class="line">                .setFieldValueEditor</span><br><span class="line">                ((fieldName,fieldValue) //接收字段名和字段值</span><br><span class="line">                        -&gt;fieldValue.toString()));//将字段值转成string类型</span><br></pre></td></tr></table></figure><h4 id="登录拦截器优化"><a href="#登录拦截器优化" class="headerlink" title="登录拦截器优化"></a>登录拦截器优化</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729115816.png" alt="微信图片_20240729115816"></p><p><strong>token刷新拦截器</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class RefreshTokenInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        // 1.获取请求头中的token</span><br><span class="line">        String token = request.getHeader(&quot;authorization&quot;);</span><br><span class="line">        if (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.基于TOKEN获取redis中的用户</span><br><span class="line">        String key  = LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        // 3.判断用户是否存在</span><br><span class="line">        if (userMap.isEmpty()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.将查询到的hash数据转为UserDTO</span><br><span class="line">        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);</span><br><span class="line">        // 6.存在，保存用户信息到 ThreadLocal</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        // 7.刷新token有效期</span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        // 8.放行</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        // 移除用户</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改登录拦截器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.判断是否需要拦截(Thread中是否有用户)</span></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser() == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没有，拦截</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有，放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将拦截器连接</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        // 登录拦截器</span><br><span class="line">        registry.addInterceptor(new LoginInterceptor())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        &quot;/shop/**&quot;,//商店</span><br><span class="line">                        &quot;/voucher/**&quot;,//优惠券</span><br><span class="line">                        &quot;/shop-type/**&quot;,//商店类型</span><br><span class="line">                        &quot;/upload/**&quot;,//更新</span><br><span class="line">                        &quot;/blog/hot&quot;,//博客</span><br><span class="line">                        &quot;/user/code&quot;,</span><br><span class="line">                        &quot;/user/login&quot;</span><br><span class="line">                ).order(1);</span><br><span class="line">        //token刷新拦截器</span><br><span class="line">        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、商户查询缓存"><a href="#二、商户查询缓存" class="headerlink" title="二、商户查询缓存"></a>二、商户查询缓存</h2><h3 id="2-1什么是缓存"><a href="#2-1什么是缓存" class="headerlink" title="2.1什么是缓存"></a>2.1什么是缓存</h3><p><strong>缓存就是数据交换的缓冲区(称作cache)，是存贮数据的临时地方，一般读写性能较高。</strong></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729170600.png" alt="微信图片_20240729170600"></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729171017.png" alt="微信图片_20240729171017.png"></p><h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729172259.png" alt="微信图片_20240729172259"></p><p><strong>查询商户代码实现</strong></p><blockquote><p>1.从redis查询商铺缓存</p><p>2.判断是否存在</p><p>3.存在，直接返回</p><p>4.不存在，查询数据库</p><p>5.不存在，返回错误<br>6.存在，写入redis<br>7.返回</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">//2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        <span class="comment">//3.存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.不存在，查询数据库</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.存在，写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">    <span class="comment">// 7.返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2店铺类型查询业务添加缓存"><a href="#2-2店铺类型查询业务添加缓存" class="headerlink" title="2.2店铺类型查询业务添加缓存"></a>2.2店铺类型查询业务添加缓存</h3><p><strong>ShopTypeController中</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/shop-type&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IShopTypeService typeService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询商户类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//List&lt;ShopType&gt; typeList = typeService</span></span><br><span class="line">        <span class="comment">//      .query().orderByAsc(&quot;sort&quot;).list();</span></span><br><span class="line">        <span class="keyword">return</span> typeService.queryShopType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务代码如上</strong></p><blockquote><p>1.从redis查询商铺缓存</p><p>2.判断是否存在</p><p>3.存在，直接返回</p><p>4.不存在，查询数据库</p><p>5.不存在，返回错误<br>6.存在，写入redis<br>7.返回</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    /**</span><br><span class="line">     * 查询商户类型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result queryShopType() &#123;</span><br><span class="line">        String key = RedisConstants.CACHE_SHOPTYPE_KEY;</span><br><span class="line">        //1.从redis中查询商户缓存</span><br><span class="line">        String shopTypeJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //2.判断存在</span><br><span class="line">        if(StrUtil.isNotBlank(shopTypeJson))&#123;</span><br><span class="line">            //3.存在，返回</span><br><span class="line">            List&lt;ShopType&gt; shopTypes = JSONUtil.toList(shopTypeJson, ShopType.class);</span><br><span class="line">            return Result.ok(shopTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        //4.不存在查数据库</span><br><span class="line">        List&lt;ShopType&gt; shopTypes = query().orderByAsc(&quot;sort&quot;).list();</span><br><span class="line">        //5.不存在，返回错误</span><br><span class="line">        if(shopTypes==null)&#123;</span><br><span class="line">            return Result.fail(&quot;类型为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //6.存在，写入redis</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shopTypes));</span><br><span class="line">        // 7.返回</span><br><span class="line">        return Result.ok(shopTypes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3缓存更新策略"><a href="#2-3缓存更新策略" class="headerlink" title="2.3缓存更新策略"></a>2.3缓存更新策略</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729183634.png" alt="微信图片_20240729183634.png"></p><h4 id="2-4主动更新策略"><a href="#2-4主动更新策略" class="headerlink" title="2.4主动更新策略"></a>2.4主动更新策略</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240729183643.png" alt="微信图片_20240729183643.png"></p><p><strong>第一种最常用</strong></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730141400.png" alt="微信图片_20240730141400.png"></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730141531.png" alt="微信图片_20240730141531.png"></p><h3 id="2-5商家缓存"><a href="#2-5商家缓存" class="headerlink" title="2.5商家缓存"></a>2.5商家缓存</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730141823.png" alt="微信图片_20240730141823.png"></p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><em>缓存穿透</em></h4><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方法有两种:</p><ul><li><p>缓存空对象   </p><ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗<br>$~~~~~~~~~$ 可能造成短期的不一致</li></ul></li><li><p>布隆过滤</p><ul><li>优点：内存占用少，没有多余的key</li><li>缺点： 实现复杂<br>$~~~~~~~~~~~$存在误判可能</li></ul></li></ul><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730144842.png" alt="微信图片_20240730144842.png"></p><p><strong>业务流程</strong></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730145058.png" alt="image.png"></p><p><strong>修改代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是空值</span></span><br><span class="line"><span class="keyword">if</span>(shopJson != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//返回错误</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺信息不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.不存在，查询数据库</span></span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"><span class="comment">//5.不存在，返回错误</span></span><br><span class="line"><span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//将空值写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(key,<span class="string">&quot;&quot;</span>, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">//返回错误信息</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730151429.png" alt="微信图片_20240730151429.png"></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730151508.png" alt="微信图片_20240730151508.png"></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730151518.png" alt="微信图片_20240730151518.png"></p><p>逻辑过期设置的一般不是TTL，设置缓存基本上是一直有效到活动结束后，才移除缓存中数据<br>之所以会逻辑过期，不是因为有效时间，而是因为数据更新了，缓存也需要更新数据，这时逻辑过期。</p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730151613.png" alt="微信图片_20240730151613.png"></p><p><strong>基于互斥锁方式解决缓存击穿问题</strong></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730151650.png" alt="微信图片_20240730151650.png"></p><p><strong>定义锁</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建锁</span><br><span class="line"> private boolean tryLock(String key)&#123;</span><br><span class="line">    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,&quot;1&quot;, LOCK_SHOP_TTL,TimeUnit.SECONDS);</span><br><span class="line">    return BooleanUtil.isTrue(flag);</span><br><span class="line"> &#125;</span><br><span class="line"> //释放锁</span><br><span class="line"> private void unLock(String key) &#123;</span><br><span class="line">stringRedisTemplate.delete(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存穿透</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Shop queryWithPassThrough(Long id) &#123;</span><br><span class="line">    String key = CACHE_SHOP_KEY + id;</span><br><span class="line">    //1.从redis查询商铺缓存</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    //2.判断是否存在</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        //3.存在，直接返回</span><br><span class="line">        return JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否是空值</span><br><span class="line">    if(shopJson != null)&#123;</span><br><span class="line">        //返回错误</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.不存在，查询数据库</span><br><span class="line">    Shop shop = getById(id);</span><br><span class="line">    //5.不存在，返回错误</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        //将空值写入redis</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key,&quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">        //返回错误信息</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //6.存在，写入redis</span><br><span class="line">    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    // 7.返回</span><br><span class="line">    return shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于互斥锁方式解决缓存击穿问题</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Shop queryWithMutex(Long id) &#123;</span><br><span class="line">    String key = CACHE_SHOP_KEY + id;</span><br><span class="line">    //1.从redis查询商铺缓存</span><br><span class="line">    String shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    //2.判断是否存在</span><br><span class="line">    if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">        //3.存在，直接返回</span><br><span class="line">        return JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断是否是空值</span><br><span class="line">    if(shopJson != null)&#123;</span><br><span class="line">        //返回错误</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.实现缓存重建</span><br><span class="line">    //4.1获取互斥锁</span><br><span class="line">    String lockKey = LOCK_SHOP_KEY+id;</span><br><span class="line">    Shop shop = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean isLock = tryLock(lockKey);</span><br><span class="line">        //4.2判断是否成功</span><br><span class="line">        if(!isLock)&#123;</span><br><span class="line">            //4.3失败，休眠并重试</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            return queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //4.4成功，根据id查询数据库</span><br><span class="line">        shop = getById(id);</span><br><span class="line">        //模拟延时</span><br><span class="line">        Thread.sleep(200);</span><br><span class="line">        //5.不存在，返回错误</span><br><span class="line">        if (shop == null) &#123;</span><br><span class="line">            //将空值写入redis</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key,&quot;&quot;, CACHE_NULL_TTL,TimeUnit.MINUTES);</span><br><span class="line">            //返回错误信息</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //6.存在，写入redis</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 7.释放互斥锁</span><br><span class="line">        unLock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">    //8.返回</span><br><span class="line">    return shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result queryById(Long id) &#123;</span><br><span class="line">    //缓存穿透</span><br><span class="line">    // Shop shop = queryWithPassThrough(id);</span><br><span class="line">    //互斥锁解决缓存击穿</span><br><span class="line">    Shop shop = queryWithMutex(id);</span><br><span class="line">    if (shop == null) &#123;</span><br><span class="line">        return Result.fail(&quot;店铺不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 7.返回</span><br><span class="line">    return Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于逻辑过期方式解决缓存击穿问题</strong></p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730162929.png" alt="微信图片_20240730162929.png"><br>代码忽略</p><h3 id="2-6缓存工具封装"><a href="#2-6缓存工具封装" class="headerlink" title="2.6缓存工具封装"></a>2.6缓存工具封装</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730163915.png" alt="微信图片_20240730163915.png"></p><ul><li>方法一和方法三应对普通缓存</li><li>方法二和方法四应对热点key解决击穿问题</li></ul><h2 id="三、优惠券秒杀"><a href="#三、优惠券秒杀" class="headerlink" title="三、优惠券秒杀"></a>三、优惠券秒杀</h2><h3 id="3-1全局ID生成器"><a href="#3-1全局ID生成器" class="headerlink" title="3.1全局ID生成器"></a>3.1全局ID生成器</h3><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性:</p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730211519.png" alt="微信图片_20240730211519.png">、</p><p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息:</p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240730212423.png" alt="微信图片_20240730212423.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RedisIdWorker &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 开始时间戳</span><br><span class="line">     */</span><br><span class="line">    private static final long BEGIN_TIMESTAMP = 1640995200L;</span><br><span class="line">    /**</span><br><span class="line">     * 序列号的位数</span><br><span class="line">     */</span><br><span class="line">    private static final int COUNT_BITS = 32;</span><br><span class="line"></span><br><span class="line">    private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) &#123;</span><br><span class="line">        this.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成ID</span><br><span class="line">     * @param keyPrefix</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public long nextId(String keyPrefix) &#123;</span><br><span class="line">        // 1.生成时间戳</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        long timestamp = nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        // 2.生成序列号</span><br><span class="line">        // 2.1.获取当前日期，精确到天</span><br><span class="line">        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));</span><br><span class="line">        // 2.2.自增长</span><br><span class="line">        long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);</span><br><span class="line"></span><br><span class="line">        // 3.拼接并返回</span><br><span class="line">        return timestamp &lt;&lt; COUNT_BITS | count;//时间戳左移32位，然后或运算拼接count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生成全局唯一ID策略：</strong></p><ul><li>UUID</li><li>Redis自增</li><li>snowflake算法</li><li>数据库自增</li></ul><p><strong>其中Redis自增策略：</strong></p><ul><li>每天一个key，方便统计订单量</li><li>ID构成时间戳+计数器</li></ul><h3 id="3-2实现优惠券秒杀下单"><a href="#3-2实现优惠券秒杀下单" class="headerlink" title="3.2实现优惠券秒杀下单"></a>3.2实现优惠券秒杀下单</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240731140830.png" alt="微信图片_20240731140830.png"></p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240731141458.png" alt="微信图片_20240731141458.png"></p><p><strong>业务实现</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 优惠券抢购</span><br><span class="line"> * @param voucherId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">@Transactional</span><br><span class="line">public Result seckillVoucher(Long voucherId) &#123;</span><br><span class="line">   //1.查询优惠券</span><br><span class="line">    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);</span><br><span class="line">    //2.判断秒杀是否开始</span><br><span class="line">    if(voucher.getBeginTime().isAfter(LocalDateTime.now()))</span><br><span class="line">    &#123;</span><br><span class="line">        //尚未开始</span><br><span class="line">        return Result.fail(&quot;秒杀尚未开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //3.判断秒杀是否结束</span><br><span class="line">    if(voucher.getEndTime().isBefore(LocalDateTime.now()))</span><br><span class="line">    &#123;</span><br><span class="line">        //结束</span><br><span class="line">        return Result.fail(&quot;秒杀已经结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //4.判断库存是否充足</span><br><span class="line">    if (voucher.getStock()&lt;1) &#123;</span><br><span class="line">        //库存不足</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //5.扣减库存</span><br><span class="line">    boolean success = seckillVoucherService.update()</span><br><span class="line">            .setSql(&quot;stock=stock-1&quot;)</span><br><span class="line">            .eq(&quot;voucher_id&quot;, voucherId).update();</span><br><span class="line">    if(!success)</span><br><span class="line">    &#123;</span><br><span class="line">        return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //6.创建订单</span><br><span class="line">    VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">    //6.1订单id</span><br><span class="line">    long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    //6.2用户id</span><br><span class="line">    Long userId = UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    //6.3代金券id</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    //7.返回订单id</span><br><span class="line">    return Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3超卖问题"><a href="#3-3超卖问题" class="headerlink" title="3.3超卖问题"></a>3.3超卖问题</h3><p>即多线程并发安全问题，常见解决方案就是加锁：</p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240801160925.png" alt="微信图片_20240801160925.png"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的方式有两种：</p><ul><li>版本号法</li><li>CAS法</li></ul><p>乐观锁的弊端，失败概率大大增加，我们只需让stock&gt;0即可<br>更新数据用乐观锁,我们采用CAS法来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//5.扣减库存</span><br><span class="line">boolean success = seckillVoucherService.update()</span><br><span class="line">        .setSql(&quot;stock=stock-1&quot;)</span><br><span class="line">        .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;,0) //stock&gt;0</span><br><span class="line">        .update();</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    return Result.fail(&quot;库存不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4一人一单"><a href="#3-4一人一单" class="headerlink" title="3.4一人一单"></a>3.4一人一单</h3><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240801165821.png" alt="微信图片_20240801165821.png"></p><p>插入数据要用悲观锁<br>反复观看视频，知识点很多<br>通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。</p><p><strong>集群模式下我们要用分布式锁。</strong></p><h3 id="3-5分布式锁——一人一单并发安全问题"><a href="#3-5分布式锁——一人一单并发安全问题" class="headerlink" title="3.5分布式锁——一人一单并发安全问题"></a>3.5分布式锁——一人一单并发安全问题</h3><p><strong>分布式锁：</strong> 满足分布式系统或集群模式下多进程可见并且互斥的锁。<br>基本特性：</p><ul><li>多进程可见</li><li>互斥</li><li>高性能</li><li>高可用</li><li>安全性</li></ul><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240808144950.png" alt="微信图片_20240808144950.png"></p><h4 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h4><p>分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种</p><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240808150249.png" alt="微信图片_20240808150249.png"></p><h4 id="基于redis的分布式锁"><a href="#基于redis的分布式锁" class="headerlink" title="基于redis的分布式锁"></a>基于redis的分布式锁</h4><p>实现分布式锁需要两个基本方法</p><ul><li><p>获取锁  </p><ul><li><p>互斥：确保只能有一个线程获取锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加锁，利用setnx的特性，添加锁过期时间，避免服务器宕机</span><br><span class="line">SET lock thread1 NX EX  10</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁</p><ul><li><p>手动释放</p></li><li><p>超时释放：获取锁时添加一个过期时间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 释放锁，删除即可</span><br><span class="line">DEL key </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="改进分布式锁"><a href="#改进分布式锁" class="headerlink" title="改进分布式锁"></a>改进分布式锁</h4><p><img src="/2024/09/30/hmdp/Github\my-blog\source\images\hmdp\微信图片_20240811113117.png" alt="微信图片_20240811113117.png"></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><h2 id="四、达人探店"><a href="#四、达人探店" class="headerlink" title="四、达人探店"></a>四、达人探店</h2><h3 id="4-1发布探店笔记"><a href="#4-1发布探店笔记" class="headerlink" title="4.1发布探店笔记"></a>4.1发布探店笔记</h3><h2 id="4-2完善点赞功能"><a href="#4-2完善点赞功能" class="headerlink" title="4.2完善点赞功能"></a>4.2完善点赞功能</h2><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><ul><li>同一个用户只能点赞一次，再次点击则取消；</li><li>如果当前用户已点赞，则点赞按钮高亮显示</li></ul><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><ul><li>给Blog类中添加一个isList字段，标记是否被当前用户点赞；</li><li>修改点赞功能，利用redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1；</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段；</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode</title>
      <link href="/2024/09/27/leetcode/"/>
      <url>/2024/09/27/leetcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target-nums[i]))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    map.put(nums[i],i);<span class="comment">//将数组中的数据放入map中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>首先创建一个map&lt;String,List<String>&gt;类型的映射对象map，用于存储单词异位分组；  </String></p></li><li><p>遍历输入的字符串strs；  </p></li><li><p>对于每一个字符串str转化为字符串数组array，然后将字符串数组进行排序，得到排序后的key  </p></li><li><p>检查映射map中是否存在键为key的键值对，若不存在，创建新的列表，将key和新列表添加到map中；若存在，获取对应的列表，并将当前字符串str添加到列表中。  </p></li><li><p>遍历结束后，返回map中的所有列表，即分组后的字母异位词列表。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str:strs)&#123;</span><br><span class="line">    <span class="type">char</span>[] array = str.toCharArray();</span><br><span class="line">    Arrays.sort(array);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span> (array);</span><br><span class="line">    List&lt;String,List&lt;String&gt;&gt; list = map.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    list.add(str);</span><br><span class="line">    map.put(key,list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h2><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>首先定义一个Set列表，将数组中的数据存入set中（使用set来存储数据，是因为它的特性：1、元素的唯一性；2、高效的查找操作；3、易于实现连续序列的操作；4、内存效率；5、代码简洁性）；</li><li>初始化序列最大长度；</li><li>接着遍历数组，判断如果nums[i]-1在set中，那么nums[i]就是起始位置，然后定义curNum为nums[i]，及len为1；while循环直到curNum+1不在set中。while循环结束将max赋值为max和len中最大的那个。</li><li>最后return max 结束。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(num-<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> num;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(set.contains(curNum+<span class="number">1</span>))&#123;</span><br><span class="line">                curNum++;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>使用快慢指针，首先两个指针指向同一个位置；</li><li>循环遍历数组，当快指针指向不为零的数时，和慢指针交换数据并且快慢指针都右移；当快指针指向零时，接着右移；</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">int n=nums.length,right=0,left=0;</span><br><span class="line">while(right&lt;n)&#123;</span><br><span class="line">if(nums[right]!=0)</span><br><span class="line">&#123;</span><br><span class="line">int tem = nums[right];</span><br><span class="line">nums[right] =nums[left];</span><br><span class="line">nums[left] = tem;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a>盛水最多的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><strong>1、暴力解法</strong></p><ol><li><p>首先初始化ans，两层循环，遍历所有线；</p></li><li><p>循环中，如果i的高度小于j的高度，取ans和(j-i)*height[i]的最大值；</p></li><li><p>循环中，如果i的高度大于j的高度，取ans和(j-i)*height[j]的最大值；</p></li><li><p>return ans。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;height.length;j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(height[i]&lt;height[j])</span><br><span class="line">          &#123;<span class="keyword">return</span> Math.max(ans,(j-i)*height[i]);&#125;</span><br><span class="line">          <span class="keyword">if</span>(height[i]&gt;height[j])</span><br><span class="line">          &#123;<span class="keyword">return</span> Math.max(ans,(j-i)*height[j]);&#125;</span><br><span class="line">      &#125;               </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>2、双指针法</strong></p><ol><li><p>定义一个头指针和一个尾指针，初始化ans为最外围的容器(j-i)*Math.min(height[i],height[j]);</p></li><li><p>当i小于j时循环，如果height[i]&lt;height[j],先i++，取ans和(j-i)*height[i]的最大值；</p></li><li><p>如果height[i]&gt;height[j],先j–，取ans和(j-i)*height[j]的最大值；</p></li><li><p>return ans。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>,ans=(j-i)*Math.max(height[i],height[j]);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&lt;height[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">return</span> Math.max(ans,(j-i)*Math.min(height[i],height[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;height[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">return</span> Math.max(ans,(j-i)*Math.min(height[i],height[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><h3 id="思路（双向双指针）"><a href="#思路（双向双指针）" class="headerlink" title="思路（双向双指针）"></a>思路（双向双指针）</h3><ol><li>初始化一个数组列表；</li><li>边界检查；</li><li>数组排序；</li><li>这部分代码开始遍历排序后的数组。如果当前数字大于零，则意味着后面的数字也大于零，不可能找到和为零的三元组，所以跳出循环。同时，它还处理了重复数字的情况，以避免重复的三元组；</li><li>这部分代码使用双指针技术（L和R）来查找满足和为零的三元组。如果找到了这样的三元组，它会将其添加到结果列表中，并跳过重复的数字。如果和小于零，则增加L指针；如果和大于零，则减少R指针。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> L=i+<span class="number">1</span>,R=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="type">int</span> sum=nums[i]+nums[L]+nums[R];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                </span><br><span class="line">                L++;</span><br><span class="line">                R--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)L++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><img src="/2024/09/27/leetcode/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241003182513.png" alt="微信截图_20241003182513" style="zoom:33%;"><p><strong>1、数组</strong></p><ol><li>定义两个数组来存放木桶从前遍历的最大木桶高度和从后遍历的最大木桶高度；</li><li>遍历两个数组，取其中最小值减去木桶的高度得到水量。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len=height.length;</span><br><span class="line">    <span class="type">int</span>[] pre_max=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    pre_max[<span class="number">0</span>]=height[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] suf_max =<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    suf_max[len-<span class="number">1</span>]=height[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">pre_max[i]=Math.max(pre_max[i-<span class="number">1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">suf_max[i]=Math.max(suf_max[i+<span class="number">1</span>],height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        ans+=Math.min(pre_max[i],suf_max[i])-height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、双指针</strong></p><ol><li>不再用两个数组来存放最大值，而是实时更新最大值；</li><li>当L&lt;&#x3D;R时开始循环，左指针从头遍历数组，右指针从尾遍历数组，并更新pre和suf的值；</li><li>做出判断，若pre&lt;suf则ans+&#x3D;pre-height[L];且指针右移；反之。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,pre=<span class="number">0</span>,suf=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> L=<span class="number">0</span>,R=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        pre=Math.max(pre,height[L]);</span><br><span class="line">        suf=Math.max(suf,height[R]);</span><br><span class="line">        <span class="keyword">if</span>(pre&lt;suf)&#123;</span><br><span class="line">            ans+=pre-height[L];</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=suf-height[R];</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="无重复字符的最大长度"><a href="#无重复字符的最大长度" class="headerlink" title="无重复字符的最大长度"></a>无重复字符的最大长度</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>初始化两个变量 L 和 ans 为 0，L 表示当前子串的左边界，ans 表示当前找到的最长子串的长度。</li><li>创建一个 HashSet 集合 oss，用于存储当前子串中的字符。</li><li>使用一个 for 循环，从左到右遍历字符串 s，R 表示当前字符的索引。滑动窗口的左边界L，有边界R；</li><li>在循环内部，使用一个 while 循环，检查当前字符 s.charAt(R) 是否已经在集合 oss 中。如果存在，则不断移除集合中最左边的字符 s.charAt(L++)，直到当前字符 s.charAt(R) 不在集合中。</li><li>将当前字符 s.charAt(R) 添加到集合 oss 中。更新 ans 的值，使其为当前子串长度 R+1-L 和之前找到的最长子串长度 ans 中的较大值。</li><li>返回ans值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> L=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; oss = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> R=<span class="number">0</span>;R&lt;s.length();R++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(oss.contains(s.charAt(R)))&#123;<span class="comment">//s.charAt：java中，charAt()方法用于返回指定索引处的字符。</span></span><br><span class="line">oss.remove(s.charAt(L++);)&#125;<span class="comment">//这里remove简化了oss.remove(s.charAt(L))；L++;L++先赋值再加一</span></span><br><span class="line">        oss.add(s.charAt(R));</span><br><span class="line">        ans=Math.max(ans,R+<span class="number">1</span>-L)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>&#x2F;&#x2F;TODO</strong></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s,String p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length(),pLen = p.length();</span><br><span class="line">    <span class="keyword">if</span>(sLen &lt; pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;pLen;i++)&#123;</span><br><span class="line">        ++sCount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ++pCount[p.charAt(i)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;sLen-pLen;i++)&#123;</span><br><span class="line">        --sCount[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]; </span><br><span class="line">        ++sCount[s.charAt(i+pLen)-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(Arrays.equals(sCount,pCount))&#123;</span><br><span class="line">        ans.add(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a>和为K的子数组</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><img src="/2024/09/27/leetcode/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241003203039.png" alt="微信截图_20241003203039" style="zoom:33%;"><ol><li>定义count为次数，pre为前面数加起来的和，用哈希表来记录pre，并放入第一个数字；</li><li>开始循环，如果哈希表中存在pre-k那么说明有子集的和是k；</li><li>每一次循环把pre放进哈希表里。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre+=nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(pre - k)) &#123;</span><br><span class="line">                count+=map.get(pre-k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(pre,map.getOrDefault(pre,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><img src="/2024/09/27/leetcode/image-20241013173725772.png" alt="image-20241013173725772" style="zoom:33%;"><p><strong>该题用双端队列实现</strong></p><p>设窗口区间为[i,j]，最大值为xj。当窗口向前移动一格，则区间变为[i+1，j+1]，即添加了nums[j+1],删除了nums[i]。</p><ol><li><p><strong>初始化：</strong> 双端队列 <em>d<strong>e</strong>q<strong>u</strong>e</em> ，结果列表 <em>res</em> ，数组长度 <em>n</em> ；</p></li><li><p>滑动窗口： 左边界范围 i∈[1−k,n−k] ，右边界范围 j∈[0,n−1] ；</p><p>若 i&gt;0 且 队首元素 deque[0] &#x3D; 被删除元素 nums[i−1] ：则队首元素出队；</p><p>删除 deque 内所有 &lt;nums[j] 的元素，以保持 deque 递减；</p><p>将 nums[j] 添加至 deque 尾部；</p><p>若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 res ；</p></li><li><p><strong>返回值：</strong> 返回结果列表 <em>res</em> ；</p></li></ol><p><img src="/2024/09/27/leetcode/image-20241013172903413.png" alt="image-20241013172903413"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||k==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque =<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>-k,j=<span class="number">0</span>;j&lt;nums.length;j++,i++)&#123;</span><br><span class="line">            <span class="comment">//删除队列头</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;deque.peekFirst()==nums[i-<span class="number">1</span>]) deque.removeFirst();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保持队列递减</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty()&amp;&amp;deque.peekLast()&lt;nums[j])deque.removeLast();</span><br><span class="line">            <span class="comment">//添加队列尾</span></span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录结果</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) res[i]=deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Solution&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="keyword">while</span>(head1!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            head1.val+=head2.val;</span><br><span class="line">        head2=head2.next;&#125;</span><br><span class="line">            <span class="keyword">if</span>(head1.next == <span class="literal">null</span> &amp;&amp; head2!=<span class="literal">null</span>)&#123;</span><br><span class="line">head1=head2.next;</span><br><span class="line">            <span class="keyword">break</span>;&#125;</span><br><span class="line">            head1=head1.next;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        merge(l1);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val &gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                head.val=head.val%<span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span>(head.next == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    head.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                head.next.val+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="最大连续子数和"><a href="#最大连续子数和" class="headerlink" title="最大连续子数和"></a>最大连续子数和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ul><li><p>动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 max</p></li><li><p>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字</p></li><li><p>如果 sum &lt;&#x3D; 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字</p></li><li><p>每次比较 sum 和 max的大小，将最大值置为max，遍历结束返回结果</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max=Integer.MIN_VALUE,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">sum+=num;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">sum=num;&#125;</span><br><span class="line">        max=Math.max(sum,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2024/07/26/Redis/"/>
      <url>/2024/07/26/Redis/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一个基于内存的 key-value 结构数据库。（与mysql共存）</p><p><strong>·基于内存存储，读写性能高</strong></p><p><strong>·适合存储热点数据(热点商品、资讯、新闻)</strong></p><p><strong>·企业应用广泛</strong></p><img src="/images/redis1.png"><h2 id="Redis的启动与服务"><a href="#Redis的启动与服务" class="headerlink" title="Redis的启动与服务"></a>Redis的启动与服务</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cmd命令行中输入redis-server.exe redis.windows.conf</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>cmd命令行中输入redis-cli.exe -h localhost -p 6379 -a </p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="5种常用数据类型介绍"><a href="#5种常用数据类型介绍" class="headerlink" title="5种常用数据类型介绍"></a>5种常用数据类型介绍</h3><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型: </p><blockquote><p>字符串 string<br>哈希 hash<br>列表 list<br>集合 set<br>有序集合 sorted set&#x2F;zset</p></blockquote><h3 id="数据类型的特点"><a href="#数据类型的特点" class="headerlink" title="数据类型的特点"></a>数据类型的特点</h3><img src="/images/redis2.png"><h2 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><blockquote><p>SET key value $~~~~~~~$设置·指定key的值<br>GET key   $~~~~~~~~~~~~~~~$获取指定key的值<br>SETEX key seconds value   设置:指定key的值，并将 key 的过期时间设为 seconds 秒<br>SETNX key value$~~~~$只有在 key 不存在时设置 key 的值</p></blockquote><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><blockquote><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令:<br>HSET key field value $~~~~~~~$ 将哈希表 key 中的字段 field 的值设为 value<br>HGET key field$~~~~~~~~~~~~~~~~~$获取存储在哈希表中指定字段的值<br>HDEL key field $~~~~~~~~~~~~~~~~$删除存储在哈希表中的指定字段<br>HKEYS key $~~~~~~~~~~~~~~~~~~~~~~$获取哈希表中所有字段<br>HVALS key $~~~~~~~~~~~~~~~~~~~~~~$获取哈希表中所有值  </p></blockquote><img src="/images/redis3.png"><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序，常用命令:<br>LPUSH key value1 [value2]$~~~~~~~~~~~~~~~~$将一个或多个值插入到列表头部<br>LRANGE key start stop$~~~~~~~~~~~~~~~~~~~~~$获取列表指定范围内的元素<br>RPOP key$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$移除并获取列表最后一个元素<br>LLEN key$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$获取列表长度  </p></blockquote><img src="/images/redis4.png"><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><blockquote><p>Redis set是string类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令:<br>SADD key member1[member2] $~~~~~~~~~~~~~~~~~~~~~$向集合添加一个或多个成员<br>SMEMBERS key $~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$返回集合中的所有成员<br>SCARD key $~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$获取集合的成员数<br>SINTER key1 [key2]$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$返回给定所有集合的交集<br>SUNION key1 [key2]$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$返回所有给定集合的并集<br>SREM key member1 [member2]$~~~~~~~~~~~~~~~~~~~~~~$删除集合中一个或多个成员  </p></blockquote><img src="/images/redis5.png"><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><blockquote><p>Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令:<br>ZADD key score1 member1 [score2 member2]$~~~~~~~~~~~~~~~~~~$向有序集合添加一个或多个成员<br>ZRANGE key start stop [WITHSCORES]$~~~~~~~~~~~~$通过索引区间返回有序集合中指定区间内的成员<br>ZINCRBY key increment member$~~~~~~~~~~~~~~~~~~~~$有序集合中对指定成员的分数加上增量increment<br>ZREM key member [member]$~~~~~~~~~~~~~~~~~~~~~~~~~$移除有序集合中的一个或多个成员</p></blockquote><img src="/images/redis6.png"><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><blockquote><p>Redis的通用命令是不分数据类型的，都可以使用的命令：<br>KEYS pattern$~~~~~~~~~~~~~~~~~~~~~~~~~$查找所有符合给定模式( pattern)的 key<br>EXISTS key$~~~~~~~~~~~~~~~~~~~~~~~~~~~~$检查给定 key 是否存在<br>TYPE key$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$返回 key 所储存的值的类型<br>DEL key$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$该命令用于在 key 存在是删除 key</p></blockquote><h2 id="Spring-Data-Redis使用方式"><a href="#Spring-Data-Redis使用方式" class="headerlink" title="Spring Data Redis使用方式"></a>Spring Data Redis使用方式</h2><img src="/images/redis7.png"><img src="/images/redis8.png">]]></content>
      
      
      
        <tags>
            
            <tag> Redis入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2024/07/16/JVM/"/>
      <url>/2024/07/16/JVM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h2><p><em>JVM本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</em><br><img src="/images/jvm1.jpg" alt="图片"></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="1）解释和运行"><a href="#1）解释和运行" class="headerlink" title="1）解释和运行"></a>1）解释和运行</h4><pre><code>对字节码文件中的指令，实时解读成机器码让计算机运行。</code></pre><h4 id="2）内存管理"><a href="#2）内存管理" class="headerlink" title="2）内存管理"></a>2）内存管理</h4><pre><code>自动为对象、方法等分配内存自动的垃圾回收机制，回收不再使用的对象</code></pre><h4 id="3）即时编译"><a href="#3）即时编译" class="headerlink" title="3）即时编译"></a>3）即时编译</h4><pre><code>对热点代码进行优化，提高执行效率</code></pre><h4 id="常见JVM虚拟机"><a href="#常见JVM虚拟机" class="headerlink" title="常见JVM虚拟机"></a>常见JVM虚拟机</h4><pre><code>HotSpotGraalVMOpenJ9DragonWell龙井</code></pre><p>其中HotSpot被最广泛使用。</p><h2 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h2><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a85d96660142afb88d833cad39ea2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2392&h=1246&s=728873&e=png&b=fefdfd" alt="image.png" width="100%"><h1 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h1><h2 id="打开字节码文件–jclasslib"><a href="#打开字节码文件–jclasslib" class="headerlink" title="打开字节码文件–jclasslib"></a>打开字节码文件–jclasslib</h2><h2 id="字节码文件的组成"><a href="#字节码文件的组成" class="headerlink" title="字节码文件的组成"></a>字节码文件的组成</h2><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90b9ef9028604b45b1e5e4eea95a6029~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2052&h=1212&s=607529&e=png&b=fefefe" alt="image.png" width="100%"><h3 id="魔数Magic"><a href="#魔数Magic" class="headerlink" title="魔数Magic"></a>魔数Magic</h3><p>文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/683adbbf73c54e77875b1de970cf14dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1762&h=802&s=301865&e=png&b=f3f2f2" alt="image.png" width="100%"><h3 id="主副版本号"><a href="#主副版本号" class="headerlink" title="主副版本号"></a>主副版本号</h3><pre><code>主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1;副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</code></pre><h1 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p> 类的生命周期描述了一个类加载、使用、卸载的整个过程。</p><h2 id="生命周期的概述"><a href="#生命周期的概述" class="headerlink" title="生命周期的概述"></a>生命周期的概述</h2><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/858cc30ef4254b559319f23c8c09694b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1912&h=321&s=159343&e=png&b=fefbfb" alt="image.png" width="100%"><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><p>1.加载阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息。<br><em><strong>程序员可以使用Java代码拓展不同的渠道。</strong></em></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cffd5774b06342f1935a732ca9d9f4cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1876&h=730&s=993952&e=png&b=fdfdfd" alt="image.png" width="100%"><p>2.类加载器在加载完类之后，Java虚拟机会将字节码的信息保存在方法区中。<br>3.类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中。<em><strong>生成-个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。</strong></em></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3b801adc3f845b49b3189c2022ef1cc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1861&h=685&s=399629&e=png&b=fefefe" alt="image.png" width="100%">4、同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象。 作用是在Java代码中去获取类的信息以及存储静态字段的数据(JDK8及之后)<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dd6facfbe4d4f119bce454e83c46764~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1219&h=512&s=303686&e=png&b=fdfcfc" alt="image.png" width="100%"><p><em><strong>对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。<br>这样Java虚拟机就能很好地控制开发者访问数据的范围。</strong></em></p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/811d3ece7a844535a58958221fbd5253~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1599&h=706&s=325415&e=png&b=fefefe" alt="image.png" width="100%"><h1 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h1><h2 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h2><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dd7afe50e7c412eaec3000c011b4038~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2429&h=645&s=416631&e=png&b=fdfdfd" alt="image.png" width="100%"><h3 id="类的生命周期-连接阶段之验证"><a href="#类的生命周期-连接阶段之验证" class="headerlink" title="类的生命周期 连接阶段之验证"></a>类的生命周期 连接阶段之验证</h3><p>连接(Linking)阶段的第一个环节是验证，验的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。</p><p>主要包含如下四部分，具体详见《Java虚拟机规范》：<br>    1.文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。<br>    2.元信息验证，例如类必须有父类(super不能为空)。<br>    3.验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。<br>    4.符号引用验证，例如是否访问了其他类中private的方法等。\</p><h3 id="类的生命周期-验证案例-版本号的检测"><a href="#类的生命周期-验证案例-版本号的检测" class="headerlink" title="类的生命周期 验证案例-版本号的检测"></a>类的生命周期 验证案例-版本号的检测</h3><p><em>主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。</em></p><h3 id="类的生命周期-连接阶段之准备"><a href="#类的生命周期-连接阶段之准备" class="headerlink" title="类的生命周期 连接阶段之准备"></a>类的生命周期 连接阶段之准备</h3><p>准备阶段为静态变量(static)分配内存并设置初始值。<br>注意:本章涉及到的内存结构只讨论JDK8及之后的版本，8之前的版本后续章节详述\</p><h3 id="类的生命周期-连接阶段之解析"><a href="#类的生命周期-连接阶段之解析" class="headerlink" title="类的生命周期 连接阶段之解析"></a>类的生命周期 连接阶段之解析</h3><p>解析阶段主要是将常量池中的符号引用替换为直接引用。<br>直接引用不在使用编号，而是使用内存中地址进行访问具体的数据</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><h3 id="类的生命周期-初始化阶段"><a href="#类的生命周期-初始化阶段" class="headerlink" title="类的生命周期 初始化阶段"></a>类的生命周期 初始化阶段</h3><p> 初始化阶段会执行静态代码块中的代码，并为静态变量赋值。<br> 初始化阶段会执行字节码文件中clinit部分的字节码指令。</p><p>  ***以下几种方式会导致类的初始化:***<br>  1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化<br>  2.调用Class.forName(String className)。<br>3.new一个该类的对象时。<br>4.执行Main方法的当前类</p><p><em><strong>clinit指令在特定情况下不会出现，比如:如下几种情况是不会进行初始化指令执行的，</strong></em><br>1.无静态代码块且无静态变量赋值语句。<br>2.有静态变量的声明，但是没有赋值语句。<br>3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。\</p><h1 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h1><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器"><a href="#什么是类加载器" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h3><p>类加载器(ClassLoader)是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。<br>类加载器只参与加载过程中的字节码获取并加载到内存这一部分。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757eeeb0b73c4ec5b7e0ad5242720570~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1832&h=715&s=660992&e=png&b=fcfcfc" alt="image.png" width="100%"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47903eb4d9de4f559f653555e668320d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1830&h=837&s=501733&e=png&b=fefdfd" alt="image.png" width="100%"><h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df78fa81217643c7ad5f42336c908c2e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1952&h=741&s=370587&e=png&b=fdfdfd" alt="image.png" width="100%"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0079f69f7abe4347a81c69ba03e4e6d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1596&h=849&s=386000&e=png&b=fcfafa" alt="image.png" width="100%"><p><em><strong>Arthas</strong></em>中类加载器相关的功能<br>类加载器的详细信息可以通过classloader命令查看:classloader-査看 classloader 的继承树，urls，类加载信息，使用 classloader 去 qetResource</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><h3 id="JDK9之后的类加载器"><a href="#JDK9之后的类加载器" class="headerlink" title="JDK9之后的类加载器"></a>JDK9之后的类加载器</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>English</title>
      <link href="/2024/06/14/English/"/>
      <url>/2024/06/14/English/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="翻译预测-第一篇"><a href="#翻译预测-第一篇" class="headerlink" title="翻译预测 第一篇"></a>翻译预测 第一篇</h1><h2 id="1-core-key-content-内容-2-the-concept-of-value-价值观念-3-generation-代-4-be-filial-to-parents-孝顺父母-5-mutual-assistance-互助-6-harmony-和谐-harmonious-和谐的-7-stability-稳定-stable-稳定的"><a href="#1-core-key-content-内容-2-the-concept-of-value-价值观念-3-generation-代-4-be-filial-to-parents-孝顺父母-5-mutual-assistance-互助-6-harmony-和谐-harmonious-和谐的-7-stability-稳定-stable-稳定的" class="headerlink" title="1.core&#x2F;key content 内容 2.the concept of value 价值观念 3.generation 代 4.be filial to parents 孝顺父母 5.mutual assistance 互助 6.harmony 和谐 harmonious 和谐的 7.stability 稳定 stable 稳定的"></a>1.core&#x2F;key content 内容 2.the concept of value 价值观念 3.generation 代 4.be filial to parents 孝顺父母 5.mutual assistance 互助 6.harmony 和谐 harmonious 和谐的 7.stability 稳定 stable 稳定的</h2><h2 id="8-Respecting-the-old-loving-the-young-and-being-filial-to-parents-are-core-contents-of-traditional-family-concept-尊老爱幼，孝顺父母是传统家庭观念的核心内容。"><a href="#8-Respecting-the-old-loving-the-young-and-being-filial-to-parents-are-core-contents-of-traditional-family-concept-尊老爱幼，孝顺父母是传统家庭观念的核心内容。" class="headerlink" title="8.Respecting the old,loving the young and being filial to parents are core contents of traditional family concept.尊老爱幼，孝顺父母是传统家庭观念的核心内容。"></a>8.<code>Respecting the old,loving the young and being filial to parents</code> are core contents of traditional family concept.尊老爱幼，孝顺父母是传统家庭观念的核心内容。</h2><h2 id="9-Family-values-also-emphasize-that-collective-interests-are-more-important-than-individual-interests-The-unity-and-mutual-assistance-among-family-members-are-treated-as-virtues-家庭观念还强调集体利益高于个人利益，家庭成员的团结和互助被视为美德。"><a href="#9-Family-values-also-emphasize-that-collective-interests-are-more-important-than-individual-interests-The-unity-and-mutual-assistance-among-family-members-are-treated-as-virtues-家庭观念还强调集体利益高于个人利益，家庭成员的团结和互助被视为美德。" class="headerlink" title="9.Family values also emphasize that collective interests are more important than individual interests.The unity and mutual assistance among family members are treated as virtues. 家庭观念还强调集体利益高于个人利益，家庭成员的团结和互助被视为美德。"></a>9.Family values also emphasize that <code>collective interests</code> are more important than <code>individual interests</code>.<code>The unity and mutual assistance</code> among family members are treated as <code>virtues.</code> 家庭观念还强调集体利益高于个人利益，家庭成员的团结和互助被视为美德。</h2><h1 id="翻译预测-第二篇"><a href="#翻译预测-第二篇" class="headerlink" title="翻译预测 第二篇"></a>翻译预测 第二篇</h1><h2 id="1-flourish-prosperity-繁荣—develop-rapidlly-蓬勃发展-2-e-commerce-电子商务-3-logistics-物流-4-live-streaming-sales-直播带货-5-hotspot-热点-6-numerous-大量的-7-platform-平台-8-merchant-商家-9-participation-参加-participate-in-参加-10-the-rapid-development-of-··的迅猛发展-11-optimization-优化"><a href="#1-flourish-prosperity-繁荣—develop-rapidlly-蓬勃发展-2-e-commerce-电子商务-3-logistics-物流-4-live-streaming-sales-直播带货-5-hotspot-热点-6-numerous-大量的-7-platform-平台-8-merchant-商家-9-participation-参加-participate-in-参加-10-the-rapid-development-of-··的迅猛发展-11-optimization-优化" class="headerlink" title="1.flourish&#x3D;prosperity 繁荣—develop rapidlly 蓬勃发展 2.e-commerce 电子商务 3.logistics 物流 4.live streaming sales 直播带货 5.hotspot 热点 6.numerous 大量的 7.platform 平台 8.merchant 商家 9.participation 参加 participate in 参加 10.the rapid development of ··的迅猛发展 11.optimization 优化"></a>1.flourish&#x3D;prosperity 繁荣—develop rapidlly 蓬勃发展 2.e-commerce 电子商务 3.logistics 物流 4.live streaming sales 直播带货 5.hotspot 热点 6.numerous 大量的 7.platform 平台 8.merchant 商家 9.participation 参加 participate in 参加 10.the rapid development of ··的迅猛发展 11.optimization 优化</h2><h2 id="12-Chinese-Internet-economy-has-been-booming-in-recent-years-A-unique-e-commerce-model-has-been-formed-中国的互联网经济近年来蓬勃发展，形成独特的电子商务模式。"><a href="#12-Chinese-Internet-economy-has-been-booming-in-recent-years-A-unique-e-commerce-model-has-been-formed-中国的互联网经济近年来蓬勃发展，形成独特的电子商务模式。" class="headerlink" title="12.Chinese Internet economy has been booming in recent years.A unique e-commerce model has been formed.中国的互联网经济近年来蓬勃发展，形成独特的电子商务模式。"></a>12.Chinese Internet economy has been <code>booming</code> in recent years.A unique e-commerce model has been formed.中国的互联网经济近年来<code>蓬勃发展</code>，形成独特的电子商务模式。</h2><h2 id="13-E-commerce-platforms-such-as-Alibaba-JD-com-and-Pinduoduo-have-not-only-changed-the-way-people-shop-but-also-have-promoted-the-development-of-related-industries-such-as-logistics-payment-and-data-analysis-阿里巴巴，京东，拼多多等电商平台不仅改变了人们购物的方式，而且推动了相关产业物流，支付，数据分析的发展。"><a href="#13-E-commerce-platforms-such-as-Alibaba-JD-com-and-Pinduoduo-have-not-only-changed-the-way-people-shop-but-also-have-promoted-the-development-of-related-industries-such-as-logistics-payment-and-data-analysis-阿里巴巴，京东，拼多多等电商平台不仅改变了人们购物的方式，而且推动了相关产业物流，支付，数据分析的发展。" class="headerlink" title="13.E-commerce platforms,such as Alibaba,JD.com and Pinduoduo have not only changed the way people shop ,but also have promoted the development of related industries ,such as logistics,payment and data analysis.  阿里巴巴，京东，拼多多等电商平台不仅改变了人们购物的方式，而且推动了相关产业物流，支付，数据分析的发展。"></a>13.<code>E-commerce platforms</code>,such as Alibaba,JD.com and Pinduoduo have not only changed the way people shop ,but also have promoted the development of related industries ,such as <code>logistics</code>,payment and data analysis.  阿里巴巴，京东，拼多多等<code>电商平台</code>不仅改变了人们购物的方式，而且推动了相关产业<code>物流</code>，支付，数据分析的发展。</h2><h2 id="14-Live-streaming-sales-and-social-e-commerce-have-become-new-consumption-hotspots-They-attract-numerous-participation-of-consumes-and-merchants-直播带货和社交电商成为新的消费热点，吸引了大量的消费者和商家的参与。"><a href="#14-Live-streaming-sales-and-social-e-commerce-have-become-new-consumption-hotspots-They-attract-numerous-participation-of-consumes-and-merchants-直播带货和社交电商成为新的消费热点，吸引了大量的消费者和商家的参与。" class="headerlink" title="14.Live streaming sales and social e-commerce have become new consumption hotspots.They attract numerous participation of consumes and merchants.直播带货和社交电商成为新的消费热点，吸引了大量的消费者和商家的参与。"></a>14<code>.Live streaming sales</code> and social e-commerce have become new <code>consumption hotspots</code>.They attract numerous participation of consumes and merchants.<code>直播带货</code>和社交电商成为新的<code>消费热点</code>，吸引了大量的消费者和商家的参与。</h2><h1 id="翻译预测-第三篇"><a href="#翻译预测-第三篇" class="headerlink" title="翻译预测 第三篇"></a>翻译预测 第三篇</h1><h2 id="1-attract-worldwide-attention-remarkable-举世瞩目-2-lunar-月球的-3-carry-out-推进-4-construct-建设-5-steadily-平稳的-6-universe-太空-7-aero-航空的"><a href="#1-attract-worldwide-attention-remarkable-举世瞩目-2-lunar-月球的-3-carry-out-推进-4-construct-建设-5-steadily-平稳的-6-universe-太空-7-aero-航空的" class="headerlink" title="1.attract worldwide attention&#x3D;remarkable  举世瞩目 2.lunar 月球的 3.carry out 推进 4.construct 建设 5.steadily 平稳的 6.universe 太空 7.aero 航空的"></a>1.attract worldwide attention&#x3D;remarkable  举世瞩目 2.lunar 月球的 3.carry out 推进 4.construct 建设 5.steadily 平稳的 6.universe 太空 7.aero 航空的</h2><h2 id="8-Chinese-space-exploration-has-made-an-achievement-attracting-worldwide-attention-中国太空探索取得了举世瞩目的成就。-9-Via-continuous-exploration-and-innovation-Chinese-aerospace-industry-has-not-only-made-a-technical-breakthrough-but-also-has-made-important-contributions-for-human-to-explore-universe-and-understand-sapce-通过不断的探索和研究，中国航天事业不仅取得技术性的突破，还为人类探索宇宙了解太空做出贡献。"><a href="#8-Chinese-space-exploration-has-made-an-achievement-attracting-worldwide-attention-中国太空探索取得了举世瞩目的成就。-9-Via-continuous-exploration-and-innovation-Chinese-aerospace-industry-has-not-only-made-a-technical-breakthrough-but-also-has-made-important-contributions-for-human-to-explore-universe-and-understand-sapce-通过不断的探索和研究，中国航天事业不仅取得技术性的突破，还为人类探索宇宙了解太空做出贡献。" class="headerlink" title="8.Chinese space exploration has made an achievement attracting worldwide attention.中国太空探索取得了举世瞩目的成就。 9.Via continuous exploration and innovation,Chinese aerospace industry has not only made a technical breakthrough,but also has made important contributions for human to explore universe and understand sapce.通过不断的探索和研究，中国航天事业不仅取得技术性的突破，还为人类探索宇宙了解太空做出贡献。"></a>8.Chinese space exploration has made an achievement attracting worldwide attention.中国太空探索取得了举世瞩目的成就。 9.Via continuous exploration and innovation,Chinese aerospace industry has not only made a technical breakthrough,but also has made important contributions for human to explore universe and understand sapce.通过不断的探索和研究，中国航天事业不仅取得技术性的突破，还为人类探索宇宙了解太空做出贡献。</h2><h1 id="翻译预测-第四篇"><a href="#翻译预测-第四篇" class="headerlink" title="翻译预测 第四篇"></a>翻译预测 第四篇</h1><h2 id="1-Chinese-batik-is-an-ancient-folk-dyeing-technoly-It-is-widely-spread-among-minorities-in-Guizhou-Yunnan-and-other-regions-中国的蜡染是一种民间古老的染色技艺。它广泛流传于贵州云南等地的少数民族中。"><a href="#1-Chinese-batik-is-an-ancient-folk-dyeing-technoly-It-is-widely-spread-among-minorities-in-Guizhou-Yunnan-and-other-regions-中国的蜡染是一种民间古老的染色技艺。它广泛流传于贵州云南等地的少数民族中。" class="headerlink" title="1.Chinese batik is an ancient folk dyeing technoly.It is widely spread among minorities in Guizhou,Yunnan and other regions.中国的蜡染是一种民间古老的染色技艺。它广泛流传于贵州云南等地的少数民族中。"></a>1.Chinese batik is an ancient folk dyeing technoly.It is widely spread among minorities in Guizhou,Yunnan and other regions.中国的蜡染是一种民间古老的染色技艺。它广泛流传于贵州云南等地的少数民族中。</h2><h3 id="dye-染色-widely-spread-广泛流传-minority-少数民族-region-地区"><a href="#dye-染色-widely-spread-广泛流传-minority-少数民族-region-地区" class="headerlink" title="dye 染色 widely spread 广泛流传 minority 少数民族 region 地区"></a>dye 染色 widely spread 广泛流传 minority 少数民族 region 地区</h3><h2 id="2-Batik-can-form-unique-patterns-by-appling-wax-on-cloth-to-dye-蜡染通过在衣服上涂蜡形成独特的图案。"><a href="#2-Batik-can-form-unique-patterns-by-appling-wax-on-cloth-to-dye-蜡染通过在衣服上涂蜡形成独特的图案。" class="headerlink" title="2.Batik can form unique patterns by appling wax on cloth to dye.蜡染通过在衣服上涂蜡形成独特的图案。"></a>2.Batik can form unique patterns by appling wax on cloth to dye.蜡染通过在衣服上涂蜡形成独特的图案。</h2><h3 id="pattern-图案-wax-蜡-apply-涂抹"><a href="#pattern-图案-wax-蜡-apply-涂抹" class="headerlink" title="pattern 图案 wax 蜡 apply 涂抹"></a>pattern 图案 wax 蜡 apply 涂抹</h3><h2 id="3-Productions-of-batik-are-colorful-and-have-numerous-patterns-Its-common-themes-include-flowers-animals-and-geometric-shapes-which-have-strong-enthnic-characteristic-蜡染作品鲜艳，图案丰富，常见的主题包括花卉动物和几何图形，具有强烈的民族特色。"><a href="#3-Productions-of-batik-are-colorful-and-have-numerous-patterns-Its-common-themes-include-flowers-animals-and-geometric-shapes-which-have-strong-enthnic-characteristic-蜡染作品鲜艳，图案丰富，常见的主题包括花卉动物和几何图形，具有强烈的民族特色。" class="headerlink" title="3.Productions of batik are colorful and have numerous patterns.Its common themes include flowers,animals and geometric shapes,which have strong enthnic characteristic. 蜡染作品鲜艳，图案丰富，常见的主题包括花卉动物和几何图形，具有强烈的民族特色。"></a>3.Productions of batik are colorful and have numerous patterns.Its common themes include flowers,animals and geometric shapes,which have strong enthnic characteristic. 蜡染作品鲜艳，图案丰富，常见的主题包括花卉动物和几何图形，具有强烈的民族特色。</h2><h3 id="geometric-几何的-enthnic-民族的-characteristic-特色的"><a href="#geometric-几何的-enthnic-民族的-characteristic-特色的" class="headerlink" title="geometric 几何的 enthnic 民族的 characteristic 特色的"></a>geometric 几何的 enthnic 民族的 characteristic 特色的</h3><h2 id="4-Nowadays-batik-craft-is-not-only-inherited-and-preserved-as-a-traditional-craft-but-also-is-innovated-and-applied-in-modern-fashion-design-今天蜡染技术不仅得到了传承和保护，也在现代时尚设计中得到了创新和应用。"><a href="#4-Nowadays-batik-craft-is-not-only-inherited-and-preserved-as-a-traditional-craft-but-also-is-innovated-and-applied-in-modern-fashion-design-今天蜡染技术不仅得到了传承和保护，也在现代时尚设计中得到了创新和应用。" class="headerlink" title="4.Nowadays,batik craft is not only inherited and preserved as a traditional craft,but also is innovated and applied in modern fashion design.今天蜡染技术不仅得到了传承和保护，也在现代时尚设计中得到了创新和应用。"></a>4.Nowadays,batik craft is not only inherited and preserved as a traditional craft,but also is innovated and applied in modern fashion design.今天蜡染技术不仅得到了传承和保护，也在现代时尚设计中得到了创新和应用。</h2><h3 id="inherite-传承的-apply-应用，涂，抹。"><a href="#inherite-传承的-apply-应用，涂，抹。" class="headerlink" title="inherite 传承的 apply 应用，涂，抹。"></a>inherite 传承的 apply 应用，涂，抹。</h3><h1 id="作文金句"><a href="#作文金句" class="headerlink" title="作文金句"></a>作文金句</h1><h2 id="With-the-constant-advancement-much-ink-has-been-spilled-on-the-importance-of-doing-sth"><a href="#With-the-constant-advancement-much-ink-has-been-spilled-on-the-importance-of-doing-sth" class="headerlink" title="With the constant advancement,much ink has been spilled on the importance of doing sth."></a>With the constant advancement,much ink has been spilled on the importance of doing sth.</h2><p>随着不断地发展，···有了更多的关注。</p><h2 id="It-is-a-sober-reminder-that-individuals-ought-to-channel-attention-to-···"><a href="#It-is-a-sober-reminder-that-individuals-ought-to-channel-attention-to-···" class="headerlink" title="It is a sober reminder that individuals ought to channel attention to ···."></a>It is a sober reminder that individuals ought to channel attention to ···.</h2><p>个人应该更关注···是一个清楚的提醒。</p><h2 id="From-my-vantage-point-····plays-an-important-role-in-the-fabric-of-their-daily-existence"><a href="#From-my-vantage-point-····plays-an-important-role-in-the-fabric-of-their-daily-existence" class="headerlink" title="From my vantage point,····plays an important role in the fabric of their daily existence."></a>From my vantage point,····plays an important role in the fabric of their daily existence.</h2><p>我的观点，····在我们的日常生活中发挥着重要作用。</p><h2 id="The-significance-of-doing-cannot-be-overstated-as-evidenced-by-the-following-reasons"><a href="#The-significance-of-doing-cannot-be-overstated-as-evidenced-by-the-following-reasons" class="headerlink" title="The significance of doing cannot be overstated,as evidenced by the following reasons."></a>The significance of doing cannot be overstated,as evidenced by the following reasons.</h2><p>···的重要性再怎么强调也不为过，这是我的原因。</p><h2 id="An-additional-justification-is-that-…can-arouse-…’s-enthusiasm-to-do…-which-begets-a-sense-of-cooperation-and-support-contributing-to-the-triumph-of-their-team-members"><a href="#An-additional-justification-is-that-…can-arouse-…’s-enthusiasm-to-do…-which-begets-a-sense-of-cooperation-and-support-contributing-to-the-triumph-of-their-team-members" class="headerlink" title="An additional justification is that …can arouse …’s enthusiasm to do…,which begets a sense of cooperation and support contributing to the triumph of their team members."></a>An additional justification is that …can arouse …’s enthusiasm to do…,which begets a sense of cooperation and support contributing to the triumph of their team members.</h2><p>还有正当理由是…可以激发..的积极性去做…，带来一系列的合作和支持致力于他们团队的成功。</p><h2 id="To-recapitulate-in-short-…-In-this-sense-only-when-exert-our-utmost-efforts-to-enhance-their-can-we-carve-out-a-more-enriched-and-fulfilling-life"><a href="#To-recapitulate-in-short-…-In-this-sense-only-when-exert-our-utmost-efforts-to-enhance-their-can-we-carve-out-a-more-enriched-and-fulfilling-life" class="headerlink" title="To recapitulate in short,….In this sense,only when exert our utmost efforts to enhance their .. can we carve out a more enriched and fulfilling life."></a>To recapitulate in short,….In this sense,only when exert our utmost efforts to enhance their .. can we carve out a more enriched and fulfilling life.</h2><p>简而言之，…只有我们拼尽全力才能建造一个美好的生活。</p><h2 id="Hyper-focus-on-one’s-appearance-can-impede-the-formation-of-meaningful-connections-with-others-thus-diabling-them-to-socialize-with-others-and-subsequently-rendering-themselves-socially-isolated"><a href="#Hyper-focus-on-one’s-appearance-can-impede-the-formation-of-meaningful-connections-with-others-thus-diabling-them-to-socialize-with-others-and-subsequently-rendering-themselves-socially-isolated" class="headerlink" title="Hyper-focus on one’s appearance can impede the formation of meaningful connections with others,thus diabling them to socialize with others and subsequently rendering themselves socially isolated."></a>Hyper-focus on one’s appearance can <code>impede</code> the formation of meaningful connections with others,thus diabling them to socialize with others and subsequently rendering themselves socially <code>isolated</code>.</h2><p>过度关注容貌的人会阻碍他们与别人联系的形成，而且不能让他们与别人社交使他们变得与社会脱节。</p><h2 id="impede-阻碍-isolated-孤立，分离"><a href="#impede-阻碍-isolated-孤立，分离" class="headerlink" title="impede 阻碍 isolated 孤立，分离"></a><code>impede 阻碍 isolated 孤立，分离</code></h2><h2 id="give-you-a-competitive-edge-in-the-job-market"><a href="#give-you-a-competitive-edge-in-the-job-market" class="headerlink" title="give you a competitive edge in the job market"></a>give you a competitive edge in the job market</h2><p>让你在人才市场中更有竞争力</p><h2 id="Universities-have-extensive-research-facilities-and-resources-which-generate-avenues-for-involvement-in-advanced-research-projects"><a href="#Universities-have-extensive-research-facilities-and-resources-which-generate-avenues-for-involvement-in-advanced-research-projects" class="headerlink" title="Universities have extensive research facilities and resources,which generate avenues for involvement in advanced research projects."></a>Universities have <code>extensive</code> research <code>facilities</code> and resources,which generate avenues for <code>involvement in</code> advanced research projects.</h2><p>大学有<code>广泛的</code>研究<code>设施</code>和资源，提供了进去先进的研究项目的机会。</p><h3 id="extensive-广泛的-facility-设施-involve-参与"><a href="#extensive-广泛的-facility-设施-involve-参与" class="headerlink" title="extensive 广泛的 facility 设施 involve 参与"></a>extensive 广泛的 facility 设施 involve 参与</h3><h2 id="（图表类）As-is-starkly-mirrored-in-the-chart-there-has-been-…-over-the-past-decade-The-chart-shows-…-This-trend-reveals-…"><a href="#（图表类）As-is-starkly-mirrored-in-the-chart-there-has-been-…-over-the-past-decade-The-chart-shows-…-This-trend-reveals-…" class="headerlink" title="（图表类）As is starkly mirrored in the chart,there has been … over the past decade.The chart shows …. This trend reveals …"></a>（图表类）As is starkly mirrored in the chart,there has been … over the past decade.The chart shows …. This trend reveals …</h2><h2 id="（名言警句）As-an-old-saying-goes-”…”This-timeless-adage-highlights-…"><a href="#（名言警句）As-an-old-saying-goes-”…”This-timeless-adage-highlights-…" class="headerlink" title="（名言警句）As an old saying goes,”…”This timeless adage highlights …"></a>（名言警句）As an old saying goes,”…”This timeless adage highlights …</h2><h2 id="作文框架"><a href="#作文框架" class="headerlink" title="作文框架"></a>作文框架</h2><h3 id="With-the-constant-advancement-much-ink-has-been-spilled-on-the-importance-of-doing-…-It-is-a-sober-reminder-that-individuals-ought-to-channel-attention-to-…From-my-vantage-point-…plays-an-important-role-in-the-fabric-of-their-daily-existences"><a href="#With-the-constant-advancement-much-ink-has-been-spilled-on-the-importance-of-doing-…-It-is-a-sober-reminder-that-individuals-ought-to-channel-attention-to-…From-my-vantage-point-…plays-an-important-role-in-the-fabric-of-their-daily-existences" class="headerlink" title="With the constant advancement,much ink has been spilled on the importance of doing ….It is a sober reminder that individuals ought to channel attention to …From my vantage point,…plays an important role in the fabric of their daily existences."></a>With the constant advancement,much ink has been spilled on the importance of doing ….It is a sober reminder that individuals ought to channel attention to …From my vantage point,…plays an important role in the fabric of their daily existences.</h3><h3 id="The-significance-of-…-cannot-be-overstated-as-evidenced-by-the-following-reasons-The-initial-explanation-is-that-…-There-is-no-doubt-that-…-An-additional-justification-is-that-…can-arouse-’s-enthusiasm-to-do-which-begets-a-sense-of-cooperation-and-support-contributing-to-the-triumph-of-their-team-members-Last-but-not-least-I-firmly-believe-that-…-The-more-the-more-…"><a href="#The-significance-of-…-cannot-be-overstated-as-evidenced-by-the-following-reasons-The-initial-explanation-is-that-…-There-is-no-doubt-that-…-An-additional-justification-is-that-…can-arouse-’s-enthusiasm-to-do-which-begets-a-sense-of-cooperation-and-support-contributing-to-the-triumph-of-their-team-members-Last-but-not-least-I-firmly-believe-that-…-The-more-the-more-…" class="headerlink" title="The significance of ….cannot be overstated,as evidenced by the following reasons.The initial explanation is that ….There is no doubt that ….An additional justification is that …can arouse ..’s enthusiasm to do ,which begets a sense of cooperation and support contributing to the triumph of their team members.Last but not least,I firmly believe that …. The more ,the more …"></a>The significance of ….cannot be overstated,as evidenced by the following reasons.The initial explanation is that ….There is no doubt that ….An additional justification is that …can arouse ..’s enthusiasm to do ,which begets a sense of cooperation and support contributing to the triumph of their team members.Last but not least,I firmly believe that …. The more ,the more …</h3><h3 id="To-recapitulate-in-short-…-In-this-sense-only-when-we-exert-our-utmost-efforts-to-enhance-their-can-we-carve-out-a-more-enriched-and-fulfilling-life"><a href="#To-recapitulate-in-short-…-In-this-sense-only-when-we-exert-our-utmost-efforts-to-enhance-their-can-we-carve-out-a-more-enriched-and-fulfilling-life" class="headerlink" title="To recapitulate in short,….In this sense,only when we exert our utmost efforts to enhance their .. can we carve out a more enriched and fulfilling life."></a>To recapitulate in short,….In this sense,only when we exert our utmost efforts to enhance their .. can we carve out a more enriched and fulfilling life.</h3><h2 id="2024-11-27"><a href="#2024-11-27" class="headerlink" title="2024.11.27"></a>2024.11.27</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a><strong>框架</strong></h3><p>​**In recent years,there has been a growing focus on…..  as we step into a society marked by the rapid development of technology.This shift in attention prompts us to explore the implications of 。。。。。 From my point of view, …..plays an important role in the fabric of our daily existences.  **</p><p>近年来，随着我们步入一个以科技快速发展为标志的社会，人们越来越关________________。这种注意力的转移促使我们 探 索 __________________ 可 能 的 影 响 。 从 我 的 观 点 看 ，________________________________________.</p><p>​**The reasons why the development of students’ creativity is of considerable importance are as follows.Perhaps the primary reason is that  developing a creative mindest is beneficial academic performance.    **</p><p>学生创造力的开发具有相当重要的原因如下。也许主要原因是培养创造性思维有利于学习成绩。</p><p>​<strong>In addition,no one could deny that the fact that creative ability can exert a positive influence on future career.The stories of most successful entrepreneurs in the world,such as Steve Jobs,provide a glimpse into how creative mind can help them find business opportunities and build a prosperous company.</strong></p><p>此外，没有人能否认创造力可以对未来的职业生涯产生积极的影响。世界上大多数成功企业家的故事，如史蒂夫·乔布斯，让我们一瞥创造性思维如何帮助他们找到商机并建立一个繁荣的公司。</p><p>​<strong>Then how to develop creativity?Perhaps the first step is that students need to read extensively to enrich mind.Another crucial step is to put novel ideas into practice.</strong></p><p>那么如何培养创造力呢？也许第一步是学生需要广泛阅读来丰富头脑。另一个关键步骤是将新想法付诸实践。</p><p>​<strong>In conclusion,there are many well-documented benefits of being creative and I highly suggest that everyone,especially university students invest effort to cultivate creativity.</strong></p><p>总之，有许多有据可查的创造性的好处，我强烈建议每个人，尤其是大学生，努力培养创造力。</p><p>​<strong>A famous and enlightening saying goes that” .”This remark conveys a thought-provoking notion that people should attach great importance to   ,    .In my opinion,exammples,.</strong></p><p>一 句 有 名 且 启 迪 人 的 话 语 说 道 : “ _____________________________ 。 ” 这 句 话 语 揭 示 了 一 个 发 人 深 省 的 道 理 : 人 们 应 该 重 视<br>_______________________ , 因为__________________________________。在我看来____________________________________________________。</p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>​<strong>As is clearly demonstrated in the bar chart,the gross enrollment ratio in higher education in China increased&#x2F;decreased dramatically from 3.4% in 1990 to 51.6% in 2019.Apparently,the figures reveal that China has made remarkable achievements in higher education.From my perspective,the reasons behind accomplishments are various.</strong></p><p>如图所示, 中国高等教育毛入学率从1990年的3.4%大幅上升到2019年的51.6%。显然, 这些数字表明中国在高等教育方面取得了显著的成就。在我看来，成就背后的原因是多方面的 。</p><p>​<strong>I can think of no better reasons than the following ones to explain this social phenomenon.In the first place,this success is bound up with technological advancement and economic growth.     Besides,Chinese government has implemented a package of policies and raised plenty of funds to make higher education more accessible to students from families in poverty.At the same time,both citizens and the whole society are the beneficiaries of the accomplishments in higher education.To be specific,receiving higher education can improve individuals’competitive edge and  contribute to the sustainable development of the whole society.</strong></p><p>想不出比下面的更好的理由来解释这个社会现象。首先，这种成功与 _______ 和经济增长密切相关。此外, 中国政府已经实施了一揽子政策并_，让更多的来自贫困家庭的学生接受高等教育。同时, ________ 和 _______都是高等教育成就的受益者。具体来说, 接受高等教育可以提高个人的竞争优势, 有助于整个社会的可持续发展。</p><p>​<strong>In conclusion,this chart is a perfect index of the remarkable achievements made in China’s higher education.Meanwhile,it is reasonable for us to believe that such a tendency will continue in the forthcoming years and definitely contribute to our country’s prosperity in the long run.</strong></p><p>总之，这张图表完美地反映了中国高等教育取得的显著成就。同时, 我们有理由相信, 这种趋势将在未来几年继续下去, 并肯定有助于我国的长期繁荣。</p><p><img src="/2024/06/14/English/image-20241203160721275.png" alt="image-20241203160721275"></p><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><strong>Nowadays,more and more choose to live an environmentally friendly lifestyle.From my perspective,reasons behind the trend are various and this phenomenon  will undoubtedly bring considerable benefits.</strong></p><p>如今，越来越多的人选择环保的生活方式。在我看来，这种趋势背后的原因是多方面的，且这种生活方式无疑会带来很多好处.</p><p>​<strong>I can think of no better reasons than the following ones to explain this social phenomenon.In the first place,governments around the world increasingly lay down a series of environmental protection laws and regulations,calling on people to protect environment.Besides,it would be universally ackonwledged that  this phenomenon is bound up with increasingly serious environmental problems worldwide.There is no doubt that both indivuals and the whole society are the beneficiaries of eco-friendly living.For instance,using energy-efficient appliances is beneficial to saving money and the sustainable development of our community.</strong></p><p>想不出比下面的更好的理由来解释这个社会现象。首先，这种成功与 _________ 和经济增长密切相关。首先, 世界各国政府越来越多地制定一系列环境保护的法规和条例, 号召人们保护环境。此外,得到普遍认同的是 这一现象与全球范围内日益严重的环境问题有关。毫无疑问，个人和整个社会都是环境友好型生活的受益者。例如, 使用节能家用电器有利于节省资金和我们社区的可持续发展。</p><p>​<strong>In conclusion,there are many well-documented benefits of adopting a green lifestyle and the government should implement a package of policies to encourage more people to live in a greener way.</strong></p><p>总之, 采用绿色生活方式有很多有据可查的好处, 且政府应该实施一揽子政策来鼓励更多的人以绿色的方<br>式生活。</p><h3 id="新框架"><a href="#新框架" class="headerlink" title="新框架"></a>新框架</h3><p>​<strong>开头写的第一句话+In recent years,there has been a growing focus on…..  as we step into a society marked by the rapid development of technology.From my point of view, …..plays an important role in the fabric of our daily existences&#x2F;reasons behind the trend are various and this phenomenon  will undoubtedly bring considerable benefits.</strong>  </p><p>​<strong>I can think of no better reasons than the following ones to explain this social phenomenon.Perhaps the primary reason is that  governments around the world increasingly lay down a series of environmental protection laws and regulations,calling on people to protect environment.In addition,no one could deny that  this phenomenon is bound up with increasingly serious environmental problems worldwide.There is no doubt that both indivuals and the whole society are the beneficiaries of eco-friendly living.For instance,using energy-efficient appliances is beneficial to saving money and the sustainable development of our community.</strong></p><p>​<strong>In conclusion,there are many well-documented benefits of adopting a green lifestyle and the government should implement a package of policies to encourage more people to live in a greener way.</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>A</title>
      <link href="/2024/06/13/A/"/>
      <url>/2024/06/13/A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次发布git博客</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
