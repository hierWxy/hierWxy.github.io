<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>bagu | 木叶村</title><meta name="author" content="草木流年"><meta name="copyright" content="草木流年"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Java基础  1.接口和抽象类的区别相似点：（1）接口和抽象类都不能实例化，（2）实现接口或者继承抽象类的普通子类都必须实现这些抽象方法。不同点：（1）抽象类可以包含普通方法和代码块，接口类中只能有抽象方法，静态方法和默认方法，（2）抽象类可以有构造方法，接口没有，（3）抽象类的成员变量可以是各种类型的，接口类中只能是public static final类型的，并且必须赋值。   2.重载">
<meta property="og:type" content="article">
<meta property="og:title" content="bagu">
<meta property="og:url" content="http://hierwxy.github.io/2024/10/10/bagu/index.html">
<meta property="og:site_name" content="木叶村">
<meta property="og:description" content="一、Java基础  1.接口和抽象类的区别相似点：（1）接口和抽象类都不能实例化，（2）实现接口或者继承抽象类的普通子类都必须实现这些抽象方法。不同点：（1）抽象类可以包含普通方法和代码块，接口类中只能有抽象方法，静态方法和默认方法，（2）抽象类可以有构造方法，接口没有，（3）抽象类的成员变量可以是各种类型的，接口类中只能是public static final类型的，并且必须赋值。   2.重载">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hierwxy.github.io/img/head.jpg">
<meta property="article:published_time" content="2024-10-10T08:25:51.000Z">
<meta property="article:modified_time" content="2024-11-15T07:28:24.961Z">
<meta property="article:author" content="草木流年">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hierwxy.github.io/img/head.jpg"><link rel="shortcut icon" href="/img/4.png"><link rel="canonical" href="http://hierwxy.github.io/2024/10/10/bagu/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'bagu',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-15 15:28:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="木叶村"><span class="site-name">木叶村</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">bagu</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-10T08:25:51.000Z" title="发表于 2024-10-10 16:25:51">2024-10-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-15T07:28:24.961Z" title="更新于 2024-11-15 15:28:24">2024-11-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="bagu"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、Java基础"><a href="#一、Java基础" class="headerlink" title="一、Java基础"></a>一、Java基础</h1><p id="101"></p>

<h2 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h2><p>相似点：<br>（1）接口和抽象类都不能实例化，<br>（2）实现接口或者继承抽象类的普通子类都必须实现这些抽象方法。<br>不同点：<br>（1）抽象类可以包含普通方法和代码块，接口类中只能有抽象方法，静态方法和默认方法，<br>（2）抽象类可以有构造方法，接口没有，<br>（3）抽象类的成员变量可以是各种类型的，接口类中只能是public static final类型的，并且必须赋值。</p>
<p id="102"></p>

<h2 id="2-重载和重写方法的区别"><a href="#2-重载和重写方法的区别" class="headerlink" title="2.重载和重写方法的区别"></a>2.重载和重写方法的区别</h2><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同；<br>重写发生在子类中，方法名、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写。</p>
<p id="103"></p>

<h2 id="3-Java中hashCode和equals方法是什么？和-有什么区别"><a href="#3-Java中hashCode和equals方法是什么？和-有什么区别" class="headerlink" title="3.Java中hashCode和equals方法是什么？和&#x3D;&#x3D;有什么区别"></a>3.Java中hashCode和equals方法是什么？和&#x3D;&#x3D;有什么区别</h2><p>hashCode用于散列存储结构中确定对象的存储位置。可用于快速比较两个对象是否相同，因为如果他们的哈希码不同，那么肯定不相等。<br>equals用于比较两个对象的内容是否相等，通常需要重写自定义比较逻辑。<br>=&#x3D;比较基本数据类型，比较它们的值；比较引用类型，比较内存地址。</p>
<p id="104"></p>

<h2 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h2><p>（1）使用try-catch-finally捕获异常，finally中的代码一定会执行，捕获异常后程序正常进行；<br>（2）使用throws声明该方法可能会抛出异常类型，出现异常类型后，程序终止。</p>
<p id="105"></p>

<h2 id="5-Java优势是什么"><a href="#5-Java优势是什么" class="headerlink" title="5.Java优势是什么"></a>5.Java优势是什么</h2><p><strong>跨平台</strong><br>首先java是跨平台的，不同平台执行的机器码是不一样的，而java因为加了一层中间层JVM，所以可以做到一次编写多平台运行，即[Write once,Run anywhere]<br>编译执行过程是先把Java源代码编译成字节码，字节码再由JVM解释或JI编译执行，而因为JIT编译时需要预热的，所以还提供了AOT，可以直接把字节码转成机器码，来让程序重启之后能迅速拉满战斗力。<br><strong>垃圾回收</strong><br>Java还提供垃圾自动回收功能，虽说手动管理内存意味着自由、精细化地掌控，但很容易出错。<br>在内存充裕的当下，将内存的管理交给GC来做，减轻了程序员编程的负担，提升了开发的效率。<br><strong>生态</strong><br>现在Java生态圈太全了，丰富的第三方类库、网上全面的资料、企业级框架、各种中间件等等。</p>
<p><strong>补充</strong></p>
<ul>
<li>1.简单易学、有丰富的类库</li>
<li>2.面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</li>
<li>3.与平台无关性（JVM是Java跨平台使用的根本）</li>
<li>4.可靠安全</li>
<li>5.支持多线程</li>
</ul>
<p id="106"></p>

<h2 id="6-什么是Java地多态特性"><a href="#6-什么是Java地多态特性" class="headerlink" title="6.什么是Java地多态特性"></a>6.什么是Java地多态特性</h2><p>多态其实是一种抽象行为，他的主要作用是让程序员可以面对抽象编程而不是具体的实现类，这样写出来的代码扩展性会更强。<br>比如某个人很喜欢吃苹果，我们在写文章描述他的时候可以写他很喜欢吃苹果，也可以写他很喜欢吃水果。<br>水果就是抽象，苹果就是具体的实现类。<br>假设这个人某天开始换口味了，他喜欢吃桃子了，如果我们之前的文章写的是水果，那么完全不需要改，如果写的是苹果，是不是需要把苹果替换成桃子了?<br>这就是多态的意义。</p>
<p>多态地实现要有继承、重写、父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</p>
<p id="107"></p>

<h2 id="7-HashMap原理"><a href="#7-HashMap原理" class="headerlink" title="7.HashMap原理"></a>7.HashMap原理</h2><p>1.HashMap在JDK1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全  2.HashMap扩容机制：<br>HashMap的默认容量是16，默认的负载因子是0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树。<br>3.HashMap存取原理<br>（1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置。<br>（2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表(JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移会发生数据覆盖的情况)</p>
 <p id="108"></p>

<h2 id="8-面向对象和面向过程的区别"><a href="#8-面向对象和面向过程的区别" class="headerlink" title="8.面向对象和面向过程的区别"></a>8.面向对象和面向过程的区别</h2><p><strong>面向对象：</strong> 是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发。<br><strong>面向过程：</strong> 是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题地过程中所发生的行为。面向对象有封装继承多态的特性，所以易于维护、易服用、易扩展。可以设计出低耦合的系统。但是性能上来说，比面向过程要低。</p>
<p id="109"></p>

<h2 id="9-Java的自动装箱和拆箱"><a href="#9-Java的自动装箱和拆箱" class="headerlink" title="9.Java的自动装箱和拆箱"></a>9.Java的自动装箱和拆箱</h2><p><strong>装箱就是自动将基本数据类型转换为包装器类型（int-&gt;Integer）;调用方法：Integer的valueOf（int）方法<br>拆箱就是自动将包装器类型转换为基本数据类型（Integer-&gt;int）；调用方法：Inerger的intValue方法</strong></p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu4-1728549801847-1.png" alt="bagu4"></p>
<p>输出结果表示i1和i2是一个对象，i3和i4不是一个对象。<br>从两个实现类的源码来看，通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已存在的对象的引用；否则创建一个新的Integer对象。<br>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2 指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu5-1728549807046-3.png" alt="bagu5"></p>
<p>原因：在某个范围内的整形数值的个数是有限的，而浮点数却不是。</p>
<p id="110"></p>

<h2 id="10-Hashcode的作用"><a href="#10-Hashcode的作用" class="headerlink" title="10.Hashcode的作用"></a>10.Hashcode的作用</h2><p>java的集合有两类，一类是list，一类是Set。前者有序可重复，后者无序不可重复。当我们在set中插入时候怎么判断是否已经存在该元素呢，可以通过equals方法，但是如果元素太多，就会比较慢。<br>于是有人发明了哈希算法来提高集合中查找元素的效率。这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的哪个区域。<br>hashcode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到他应该放置的物理位置上。如果这个位置上没有元素，他就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其他的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<p id="111"></p>

<h2 id="11-ArrayList和LinkedList的区别"><a href="#11-ArrayList和LinkedList的区别" class="headerlink" title="11.ArrayList和LinkedList的区别"></a>11.ArrayList和LinkedList的区别</h2><p><strong>ArrayList:</strong></p>
<ul>
<li>优点: ArrayList是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高。</li>
<li>缺点：因为地址连续，ArrayList要移动数据，所以插入和删除操作效率比较低。</li>
</ul>
<p><strong>LinkedList：</strong></p>
<ul>
<li>优点：LinkedList基于链表的数据结构，地址是任意的，所以在开拓内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList比较占优势。LinkedList适用于要头尾操作或插入指定位置的场景。</li>
<li>缺点：因为LinkedList要移动指针，所以查询操作性能比较低。</li>
</ul>
<p><strong>使用场景分析：</strong></p>
<ul>
<li>当需要对数据进行随机访问的时候，选用ArrayList；</li>
<li>当需要对数据进行多次增加删除修改时，采用LinkedList。</li>
</ul>
<p>如果容量固定，并且只会添加到尾部，不引起扩容，优先采用ArrayList。</p>
<p>当然绝大多数业务的场景下，使用ArrayList就够了，但是需要注意避免ArrayList的扩容，以及非顺序的插入。</p>
<h2 id="12-HashMap和HashTable的区别"><a href="#12-HashMap和HashTable的区别" class="headerlink" title="12.HashMap和HashTable的区别"></a>12.HashMap和HashTable的区别</h2><h3 id="1、两者父类不同"><a href="#1、两者父类不同" class="headerlink" title="1、两者父类不同"></a>1、两者父类不同</h3><h3 id="2、对外提供的接口不同"><a href="#2、对外提供的接口不同" class="headerlink" title="2、对外提供的接口不同"></a>2、对外提供的接口不同</h3><h3 id="3、对null的支持不同"><a href="#3、对null的支持不同" class="headerlink" title="3、对null的支持不同"></a>3、对null的支持不同</h3><h3 id="4、安全性不同"><a href="#4、安全性不同" class="headerlink" title="4、安全性不同"></a>4、安全性不同</h3><h3 id="5、初始容量大小和每次扩充容量大小不同"><a href="#5、初始容量大小和每次扩充容量大小不同" class="headerlink" title="5、初始容量大小和每次扩充容量大小不同"></a>5、初始容量大小和每次扩充容量大小不同</h3><h3 id="6、计算hash值方法不同"><a href="#6、计算hash值方法不同" class="headerlink" title="6、计算hash值方法不同"></a>6、计算hash值方法不同</h3><h2 id="13、泛型常用特点"><a href="#13、泛型常用特点" class="headerlink" title="13、泛型常用特点"></a>13、泛型常用特点</h2><p>泛型的定义：</p>
<p>顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如ArrayList作为集合可以存放各种元素，如Integer，String，自定义的各种类型等，但我们使用的时候可以通过具体的规则来约束，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; l1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>使用泛型的好处：</p>
<ol>
<li>我们不必因为添加元素类型的不同而定义不同类型的集合；</li>
<li>我们可以通过规则按照自己的想法控制存储的数据类型。</li>
</ol>
<h2 id="14、Java创建对象有几种方式"><a href="#14、Java创建对象有几种方式" class="headerlink" title="14、Java创建对象有几种方式"></a>14、Java创建对象有几种方式</h2><p>四种方式：</p>
<p><strong>new创建新对象</strong></p>
<p><strong>通过反射机制</strong></p>
<p>使用 newInstance()，但是得处理两个异常 InstantiationException、 IllegalAccessException ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user=User.class.newInstance();</span><br><span class="line"> Object object=(Object)Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).newInstance()</span><br></pre></td></tr></table></figure>



<p><strong>采用clone机制</strong></p>
<p><strong>通过序列化机制</strong></p>
<p>调用 ObjectInputStream 类的 readObject() 方法。 我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造 函 数。 一个对象实现了 Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创 建对 象。</p>
<h2 id="15、有没有可能两个不相等的对象有相同的hashcode"><a href="#15、有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="15、有没有可能两个不相等的对象有相同的hashcode"></a>15、有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能。在产生hash冲突时，两个不相等的对象就会有相同的hashcode值。当hash冲突产生时，一般有以下几种方式：</p>
<ol>
<li>拉链法:  每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一 个单向链 表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </li>
<li>开放地址法：：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散 列地址总 能找到，并将记录存入;</li>
<li>在哈希：又叫双哈希法，有多个不同的Hash函数.当发生冲突时，使用第二个，第三个…. 等哈希函数 计算地址，直到无冲突。</li>
</ol>
<p id="2"></p>

<h2 id="16、深拷贝和浅拷贝的区别是什么"><a href="#16、深拷贝和浅拷贝的区别是什么" class="headerlink" title="16、深拷贝和浅拷贝的区别是什么"></a>16、深拷贝和浅拷贝的区别是什么</h2><ul>
<li>浅拷贝：<strong>增加了一个指针只想已存在的内存地址。</strong>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。</li>
<li>深拷贝：<strong>增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</strong>被复制对象的所有变量都含有与原来的对象相同的值。而那些引用其他对象的变量将指向被复制过的新对象。而不再是原有的那些被引用的对象。换言之，深拷贝把复制的对象所引用的对象都复制了一遍。</li>
</ul>
<h2 id="17、final的用法"><a href="#17、final的用法" class="headerlink" title="17、final的用法"></a>17、final的用法</h2><ul>
<li>被final修饰的类不可以被继承；</li>
<li>被final修饰的方法不可以被重写；</li>
<li>被final修饰的变量不可以被改变；如果修饰引用，那么引用不可变，引用指向的内容可变；</li>
<li>被final修饰的方法，JVM会尝试将其内联，提高运行效率；</li>
<li>被final修饰的常量，再编译阶段会存入常量池中。</li>
</ul>
<h2 id="18、a-a-b和a-b有什么区别"><a href="#18、a-a-b和a-b有什么区别" class="headerlink" title="18、a&#x3D;a+b和a+&#x3D;b有什么区别"></a>18、a&#x3D;a+b和a+&#x3D;b有什么区别</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">b=a+b;<span class="comment">//编译错误：cannot convert from int to byte</span></span><br><span class="line">b+=a;</span><br></pre></td></tr></table></figure>

<p>+&#x3D;操作符会对右边的表达式结果强制匹配左边的数据类型</p>
<h2 id="19、try-catch-finally-try里有return-finally还执行吗？"><a href="#19、try-catch-finally-try里有return-finally还执行吗？" class="headerlink" title="19、try catch finally,try里有return,finally还执行吗？"></a>19、try catch finally,try里有return,finally还执行吗？</h2><p>执行，并且finally的执行早于try里面的return</p>
<p><strong>结论：</strong></p>
<p>1、不管有没有出现异常，finally块中代码都会执行；</p>
<p>2、当try和catch中有return时，finally仍然会执行；</p>
<p>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值时再finally执行前确定的；</p>
<p>4、finally中最好不要包含return，否则会提前退出，返回值不是try和catch中保存的值。</p>
<h2 id="20、Excption与Error包结构"><a href="#20、Excption与Error包结构" class="headerlink" title="20、Excption与Error包结构"></a>20、Excption与Error包结构</h2><p><strong>java可抛出（Throwable）的结构分为三种类型：被检查的异常(CheckedException)，运行时的异常(RuntimeException)，和错误(Error)</strong></p>
<ol>
<li>运行时异常</li>
</ol>
<ul>
<li>定义:RuntimeException 及其子类都被称为运行时异常。</li>
<li></li>
</ul>
<h2 id="21、OOM你遇到过哪些情况，SOF你遇到过哪些情况"><a href="#21、OOM你遇到过哪些情况，SOF你遇到过哪些情况" class="headerlink" title="21、OOM你遇到过哪些情况，SOF你遇到过哪些情况"></a>21、OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><p><strong>OOM:</strong></p>
<ol>
<li><p><strong>OutOfMemoryError异常</strong></p>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生</p>
<p>OutOfMemoryError（OOM）异常的可能。</p>
<p>Java Heap 溢出：</p>
<p>一般的异常信息：java.lang.OutOfMemoryError:Java heap spacess。</p>
<p>java堆用于存储对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，这些对象数量达到最大堆容量限制后产生内存溢出异常。出现这种异常，一般手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清时因为内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄露对象到GCRoots的引用链。于是就能找到泄露对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。</p>
</li>
<li><p><strong>虚拟机栈和本地方法栈溢出</strong></p>
<p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常，这里需要注意当栈的大小越大可分配的线程数就越少。</p>
</li>
<li><p><strong>运行时常量池溢出</strong></p>
<p>异常信息：java.lang.OutOfMemoryError:PermGenspace</p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用String，intern()这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于 常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从 而间接限制其中常量池的容量。</p>
</li>
<li><p><strong>方法区溢出</strong></p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有 可 能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。 异常信息：java.lang.OutOfMemoryError:PermGenspace 方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛 刻 的。在经常动态生成大量Class的应用中，要特别注意这点。</p>
</li>
</ol>
<p><strong>SOF（堆栈溢出StackOverflow）</strong></p>
<p>StackOverflowError 的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。 因为栈一般默认为1—2m ，一旦出现死循环或者是大量的递归调用，在不断地压栈过程中，造成 栈容 量超过1m而导致溢出。 栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、 List、map数据过大。</p>
<h2 id="22、简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#22、简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="22、简述线程、程序、进程的基本概念。以及他们之间关系是什么"></a>22、简述线程、程序、进程的基本概念。以及他们之间关系是什么</h2><p><strong>线程</strong>与进程类似，但是线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享一块内存空间和一组系统资源，所以系统在产生一个线程，或者在各个线程之间做切换工作时，负担比进程小得多，所以县城被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或者其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的依次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的， 而 各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="23、、Java中IO流"><a href="#23、、Java中IO流" class="headerlink" title="23、、Java中IO流"></a>23、、Java中IO流</h2><p><strong>Java中IO流分几种</strong></p>
<ul>
<li>按照流的流向分，输入流和输出流</li>
<li>按照操作单元分，字节流和字符流</li>
<li>按照流的角色分，节点流和处理流</li>
</ul>
<p>JavaIO流的40多个类都是从如下4个抽象基类派生出来的</p>
<ul>
<li><strong>InputStream&#x2F;Reader</strong>：所有的输入流的基类，前者是字节输入流，后者是字符输入流</li>
<li><strong>OutputStream&#x2F;Writer</strong>：所有的输出流的基类，前者是字节输出流，后者是字符输出流</li>
</ul>
<p>按操作方式分类：</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu2.png" alt="bagu2"></p>
<p>按操作对象分类分：</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu1.png" alt="bagu1"></p>
<h2 id="24、Java反射的作用原理"><a href="#24、Java反射的作用原理" class="headerlink" title="24、Java反射的作用原理"></a>24、Java反射的作用原理</h2><p><strong>1、定义：</strong></p>
<p>反射机制是在运行时，对于任意的一个类，都能知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<p>​	这种动态获取的信息以及动态调用对象的方法的功能成为Java语言的反射机制。</p>
<p><strong>2、哪里会用到反射机制</strong></p>
<p>jdbc就是典型的反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&#x27;com.mysql.jdbc.Driver.class&#x27;</span>);<span class="comment">//加载 MySQL 的驱动类</span></span><br></pre></td></tr></table></figure>

<p><strong>3、反射的实现方式</strong></p>
<p>获取Class对象，有四种方法：</p>
<ol>
<li>Class.forName(“类的路径”）；</li>
<li>类名.class</li>
<li>对象 名.getClass() </li>
<li>基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class 对象</li>
</ol>
<p><strong>4、实现Java反射的类：</strong></p>
<ol>
<li>Class：表示正在运行的Java应用程序中的类和接口 注意： 所有获取对象的信息都需要Class 类 来实现。</li>
<li>Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</li>
<li>Constructor： 提供关于类的单个构造方法的信息以及它的访问权限 。</li>
<li>Method：提供类或接口 中某个方法的信息。</li>
</ol>
<p><strong>5、反射机制的优缺点</strong></p>
<p>优点：</p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性；</li>
<li>与动态编译结合</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li>通过setAccessible(true) 关闭JDK的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多</li>
<li>ReflectASM 工具类，通过字节码生成的方式加快反射速度</li>
</ol>
</li>
<li><p>相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p>
</li>
</ul>
<h2 id="25、List，Set，Map三者区别"><a href="#25、List，Set，Map三者区别" class="headerlink" title="25、List，Set，Map三者区别"></a>25、List，Set，Map三者区别</h2><p><strong>List , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口</strong></p>
<ul>
<li><p><strong>List(对付顺序的好帮手，有序可重复)：</strong>List接口存储一组不唯一(可以有多个元素引用相同的对象)，有序的对象；</p>
</li>
<li><p><strong>Set(注重独一无二的性质，无序，唯一)：</strong>不允许重复的集合。不会有多个元素引用相同的对象；</p>
</li>
<li><p><strong>Map(用Key搜索的专家)：</strong>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但是key不能重复，典型的Key是String类型，但也可以是任何对象。</p>
</li>
<li><p>Set下有<strong>HashSet，LinkedHashSet，TreeSet</strong></p>
</li>
<li><p>List下有<strong>ArrayList，Vector，LinkedList</strong></p>
</li>
<li><p>Map下有<strong>Hashtable，LinkedHashMap，HashMap，TreeMap</strong></p>
</li>
</ul>
<p><strong>笔记</strong></p>
<p>**List 的常用方法 **</p>
<ul>
<li><p>.add()：向集合中添加数据；</p>
</li>
<li><p>.remove(); &#x2F;&#x2F;可以是index和Object类型。Object移除第一次出现的指定元素。</p>
</li>
<li><p>.indexOf(“ab”);<em>返回第一个字符的下标</em></p>
</li>
<li><p>.lastIndexOf(“a”);<em>返回最后一个字符的下标</em></p>
</li>
<li><p>.size()：统计集合中有多少元素（元素可以重复储存）</p>
</li>
<li><p>.get(index);获取对应位置index的数据，用法与数组相似，从零开始计数。</p>
</li>
<li><p>.set(index,obj); &#x2F;&#x2F;修改集合的数值</p>
</li>
<li><p>.contains(Object o) &#x2F;&#x2F;list是否包含对象o;</p>
</li>
<li><p>.clear &#x2F;&#x2F;移除所有元素;</p>
</li>
<li><p>.isEmpty()：判断集合中是否有元素，若有则返回true；若没有，则返回false</p>
</li>
</ul>
<p><strong>Set常用方法</strong></p>
<ul>
<li>add():添加元素</li>
<li>remove():从集合中删除指定的元素。</li>
<li>contains():判断集合中是否包含指定的元素。</li>
<li>isEmpty():判断集合是否为空。</li>
<li><code>size()</code>：返回集合中的元素数量。</li>
<li></li>
</ul>
<p><strong>Map常用方法</strong></p>
<ul>
<li><p>put(key,value);   添加、修改。</p>
</li>
<li><p>remove():删除指定 key 对应的键值对</p>
</li>
<li><p>-size();          返回元素的个数</p>
</li>
<li><p>-get(key);        根据键返回相关联的值，如果不存在指定的键，返回null</p>
</li>
<li><p>-keySet()         返回键的Set集合</p>
</li>
<li><p>values():       返回 Map 中所有 value 的集合</p>
</li>
<li><p>entrySet()        返回键值对的Set集合</p>
</li>
<li><p>containsKey和containsValue:用于判断 Map 中是否包含指定的 key 或 value 值</p>
</li>
<li><p>isEmpty(): 判断 Map 是否为空</p>
</li>
<li><p>clear(): 清空 Map 中所有的键值对</p>
</li>
</ul>
<h1 id="二、Java多线程"><a href="#二、Java多线程" class="headerlink" title="二、Java多线程"></a>二、Java多线程</h1><p id="3"></p>

<h1 id="三、JVM"><a href="#三、JVM" class="headerlink" title="三、JVM"></a>三、JVM</h1><p id="301"></p>

<h2 id="1、知识点汇总"><a href="#1、知识点汇总" class="headerlink" title="1、知识点汇总"></a>1、知识点汇总</h2><p>JVM是Java运行基础，面试时一定会遇到JVM有关问题，内容集中</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu6.png" alt="bagu6"></p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu7.png" alt="bagu7"></p>
<p>其中内存模型，类加载机制，GC是重点方面。性能调优部分更偏向应用，重点突出实践能力。编译器优化和执行模式部分偏向于理论基础，重点掌握知识点。<br>需了解<strong>内存模型</strong>各部分作用，保存哪些数据.<br><strong>类加载</strong>双亲委派加载机制，常用加载器分别加载哪种类型的类.<br><strong>GC分代回收</strong>的思想和依据以及不同垃圾回收算法的回收思路和适合场景.<br><strong>性能调优常</strong>有JVM优化参数作用，参数调优的依据，常用的JVM分析工具能分析哪些问题以及使 用方法.<br><strong>执行模式</strong>解释&#x2F;编译&#x2F;混合模式的优缺点，Java7提供的分层编译技术，JIT即时编译技术，OSR栈上 替 换，C1&#x2F;C2 编译器针对的场景，C2针对的是server模式，优化更激进.新技术方面Java10的graal编译器<br><strong>编译器</strong>优化javac的编译过程，ast抽象语法树，编译器优化和运行器优化</p>
<p id="302"></p>

<h2 id="2、知识点详解"><a href="#2、知识点详解" class="headerlink" title="2、知识点详解"></a>2、知识点详解</h2><h3 id="1-JVM内存模型"><a href="#1-JVM内存模型" class="headerlink" title="1.JVM内存模型"></a>1.JVM内存模型</h3><p>线程独占：栈，本地方法栈，程序计数器 线程共享：堆，方法区</p>
<h3 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h3><p>又称方法栈，线程私有的，线程执行方法是会创建一个栈桢，用来存储局部变量表，操作栈，动态链接，方法出口等信息，调用方法时执行入栈，方法返回时执行出栈。</p>
<p id="4"></p>

<h1 id="四、Mysql"><a href="#四、Mysql" class="headerlink" title="四、Mysql"></a>四、Mysql</h1><h2 id="1、select语句完整的执行顺序"><a href="#1、select语句完整的执行顺序" class="headerlink" title="1、select语句完整的执行顺序"></a>1、select语句完整的执行顺序</h2><p>SQL Select 语句完整的执行顺序：</p>
<ol>
<li>from子句组装来自不同数据源的数据；</li>
<li>where子句基于指定的条件对记录进行筛选</li>
<li>group by 子句将数据划分为多个分组</li>
<li>使用聚集函数进行计算</li>
<li>使用having子句筛选分组</li>
<li>计算所有的表达式</li>
<li>select的字段</li>
<li>使用order by对结果集进行排序</li>
</ol>
<h2 id="2、MySQL事务"><a href="#2、MySQL事务" class="headerlink" title="2、MySQL事务"></a>2、MySQL事务</h2><p><strong>事务的基本要素（ACID）</strong></p>
<ul>
<li><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做， 不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的 操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原 子，是物质构成的基本单位。</li>
<li><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破 坏 。比如 A 向 B转账，不可能A扣了钱，B却没收到。</li>
<li><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务 之间彼此没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前， B 不能向这张卡转账。</li>
<li><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据 库，不能回滚。</li>
</ul>
<p><strong>MySQL事务隔离级别</strong></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读提交（read-committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>事务的并发问题</strong></p>
<ul>
<li><strong>脏读：</strong>事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的 数据是脏数据</li>
<li><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程 中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致</li>
<li><strong>幻读：</strong>系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等 级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改 结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 如何解决脏读、幻读、不可重复读</li>
</ul>
<p><strong>如何解决脏读、幻读、不可重复读</strong></p>
<ul>
<li>脏读： 隔离级别为 读提交、可重复读、串行化可以解决脏读</li>
<li>不可重复读：隔离级别为可重复读、串行化可以解决不可重复读</li>
<li>幻读：隔离级别为串行化可以解决幻读、通过MVCC+区间锁可以解决幻读</li>
</ul>
<p><strong>小结：</strong></p>
<p>不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。 解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="4、悲观锁和乐观锁怎么实现"><a href="#4、悲观锁和乐观锁怎么实现" class="headerlink" title="4、悲观锁和乐观锁怎么实现"></a>4、悲观锁和乐观锁怎么实现</h2><p id="6"></p>

<h1 id="五、Redis"><a href="#五、Redis" class="headerlink" title="五、Redis"></a>五、Redis</h1><h2 id="1、为什么要用缓存"><a href="#1、为什么要用缓存" class="headerlink" title="1、为什么要用缓存"></a>1、为什么要用缓存</h2><p>使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。Redis的读写性能比Mysql好得多，我们就可以把Mysql中的热点数据缓存到Redis中，提升读取性能，同时也减轻了Mysql的读取压力。</p>
<h2 id="2、说一下Redis有什么优点和缺点"><a href="#2、说一下Redis有什么优点和缺点" class="headerlink" title="2、说一下Redis有什么优点和缺点"></a>2、说一下Redis有什么优点和缺点</h2><p><strong>优点</strong></p>
<ul>
<li><strong>速度快：</strong>因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1);</li>
<li><strong>支持丰富的数据结构：</strong>支持String，List，Set，SortedSet，Hash五种基础的数据结构。</li>
<li><strong>持久化存储：</strong>Redis提供RDB和AOF两种数据的持久化存储方案，解决内存数据库最担心的万一Redis挂掉，数据会消失的问题。</li>
<li><strong>高可用：</strong>内置Redis，Sentinel，提供高可用方案，实现主从故障自动转移。内置Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模。</li>
<li><strong>丰富的特性：</strong>Key过期、计数、分布式锁、消息队列等。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于Redis是内存数据库，所以，单台机器存储的数据量，跟机器本身的内存大小有关。虽然Redis本身有Key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据；</li>
<li>如果进行完整重同步，由于需要生成RDB文件，并进行传输，会占用主机的CPU，并会消耗网的带宽。</li>
<li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis不能提供服务。</li>
</ul>
<h2 id="3、什么是Redis"><a href="#3、什么是Redis" class="headerlink" title="3、什么是Redis"></a>3、什么是Redis</h2><p>Redis是一个开源、基于内存、支持多种数据结构的存储系统，可以作为数据库缓存和消息中间件。它支持的数据结构有字符串(Strings)、哈希(hashes)、列表(sets)、有序集合(sorted sets)等，除此之外还支持bitmaps\hyperlologs和地理空间(geospatial)索引半径查询等功能。</p>
<p>它内置了复制、LUA脚本、LRU驱动事件、事务和不同级别的磁盘持久化功能，并通过Redis哨兵和集群保证缓存的高可用性。</p>
<h2 id="4、为什么Redis单线程模型效率也能那么高"><a href="#4、为什么Redis单线程模型效率也能那么高" class="headerlink" title="4、为什么Redis单线程模型效率也能那么高"></a>4、为什么Redis单线程模型效率也能那么高</h2><ol>
<li>C语言实现，效率高；</li>
<li>纯内存操作；</li>
<li>基于非阻塞的IO复用模型机制；</li>
<li>单线程的话能避免多线程的频繁上下文切换问题；</li>
<li>丰富的数据结构(全程采用hash结构，读取速度非常快，对数据存储进行了一些优化)</li>
</ol>
<h2 id="5、说说Redis的线程模型-基于非阻塞的IO复用模型机制"><a href="#5、说说Redis的线程模型-基于非阻塞的IO复用模型机制" class="headerlink" title="5、说说Redis的线程模型(基于非阻塞的IO复用模型机制)"></a>5、说说Redis的线程模型(基于非阻塞的IO复用模型机制)</h2><p>Redis内部使用文件事件处理器(file event handler),这个文件事件处理器是单线程的，所以Redis才叫做单线程的模型。它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含4部分：</p>
<ol>
<li>多个socket；</li>
<li>IO多路服用程序；</li>
<li>文件事件分派器；</li>
<li>事件处理器(连接应答处理器，命令请求处理器，命令回复处理器)</li>
</ol>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<h2 id="6、为什么Redis需要把所有数据放到内存中？"><a href="#6、为什么Redis需要把所有数据放到内存中？" class="headerlink" title="6、为什么Redis需要把所有数据放到内存中？"></a>6、为什么Redis需要把所有数据放到内存中？</h2><p>Redis将数据放在内存中有一个好处，那就是可以实现最快地对数据读取，如果数据存储在硬盘中，磁盘I&#x2F;O会严重影响Redis的性能。而且Redis还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，Redis的使用也被应用的越来越多，使得它拥有很大的优势。</p>
<h2 id="7、Redis的同步机制是什么"><a href="#7、Redis的同步机制是什么" class="headerlink" title="7、Redis的同步机制是什么"></a>7、Redis的同步机制是什么</h2><p>Redis支持主从同步、从同步。如果是第一次进行主从同步，主节点需要使用bgsave命令，再将后续修改操作记录到内存的缓冲区，等RDB文件全部同步到复制节点，复制节点接收完成后将RDB镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p>
<h2 id="8、Redis缓存刷新策略有哪些"><a href="#8、Redis缓存刷新策略有哪些" class="headerlink" title="8、Redis缓存刷新策略有哪些"></a>8、Redis缓存刷新策略有哪些</h2><p id="7"></p>

<h1 id="六、计算机网络系列"><a href="#六、计算机网络系列" class="headerlink" title="六、计算机网络系列"></a>六、计算机网络系列</h1><p id="8"></p>

<h1 id="七、linux"><a href="#七、linux" class="headerlink" title="七、linux"></a>七、linux</h1><h1 id="八、maven篇"><a href="#八、maven篇" class="headerlink" title="八、maven篇"></a>八、maven篇</h1><h2 id="1、什么是maven？"><a href="#1、什么是maven？" class="headerlink" title="1、什么是maven？"></a>1、什么是maven？</h2><p>maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。</p>
<p>maven项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统和用来运行定义在生命周期阶段中插件目标的逻辑。当使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的插件。</p>
<h2 id="2、maven能为我们解决什么问题"><a href="#2、maven能为我们解决什么问题" class="headerlink" title="2、maven能为我们解决什么问题"></a>2、maven能为我们解决什么问题</h2><ol>
<li><p><strong>添加第三方jar包</strong></p>
<p>按照最原始的做法，我们是手动复制jar包到项目WEB-INF&#x2F;lib下，每个项目都会有一份，造成 大量 重复文件。<strong>而Maven将jar包放在本地仓库中统一管理，需要jar包只需要用坐标的方式引用即可。</strong></p>
</li>
<li><p><strong>jar包之间的依赖关系</strong></p>
<p>jar 包之间往往不是独立的，很多jar需要在其他jar包的支持下才能够正常工作，称为jar包之 间的依 赖关系。如果我们手动去导入，要知道jar包之间的依赖关系并一一导入是极其麻烦而且 容易出错 的。<strong>如果使用Maven，它能够将当前jar包所依赖的其他所有jar包全部导入。</strong></p>
</li>
<li><p><strong>获取第三方jar包</strong></p>
<p>开发过程中我们需要用到很多jar包，每个jar包在官网获取的方式不尽相同，给工作带来了额外困难。<strong>但是使用Maven可以以坐标的方式依赖一个jar包，Maven从中央仓库进行下载，并同时下载这 个jar包依赖的其他jar包。</strong></p>
</li>
<li><p><strong>将项目拆分为多个工程模块</strong></p>
<p>项目的规模越来越大，已经不可能通过package结构来划分模块，必须将项目拆分为多个工程协同开发。</p>
</li>
</ol>
<h2 id="3、说说maven有什么优缺点"><a href="#3、说说maven有什么优缺点" class="headerlink" title="3、说说maven有什么优缺点"></a>3、说说maven有什么优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>简化了项目依赖管理</li>
<li>易于上手，对于新手来说了解几个常用命令即可满足日常工作；</li>
<li>便于与持续集成工具(jenkins)整合；</li>
<li>便于项目升级，无论是项目本身还是项目使用的依赖；</li>
<li>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Maven是一个庞大的构建系统，学习难度大；入门容易精通难；</li>
<li>Maven采用约定由于配置的策略，虽然上手容易但是一旦出现问题，难于调试中网络环境较差，很多repository无法访问。</li>
</ul>
<h2 id="4、什么是maven坐标"><a href="#4、什么是maven坐标" class="headerlink" title="4、什么是maven坐标"></a>4、什么是maven坐标</h2><p>Maven 其中一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。为了能自动化地解析任何一个Java构件，Maven必须将这些Jar包或者其他资源进行唯一标识，这是管理项目的依赖的基础，也就是我们要说的坐标。包括我们自己开发的项目，也是要通过坐标进行唯一 标识的，这样 才能在其他项目中进行依赖引用。</p>
<p>maven的坐标通过groupId，artifactId，version唯一标志一个构件。groupId通常为公司或组织名字，artifactId通常为项目名称，version为版本号。</p>
<h2 id="5、讲一下maven的生命周期"><a href="#5、讲一下maven的生命周期" class="headerlink" title="5、讲一下maven的生命周期"></a>5、讲一下maven的生命周期</h2><p>Maven的生命周期：从我们的项目构建，一直到项目发布的这个过程。</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/bagu3.png" alt="bagu3"></p>
<p>每个阶段的说明：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>处理</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>validate</td>
<td>验证项目</td>
<td>验证项目是否正确且所有必须信息是可用的</td>
</tr>
<tr>
<td>compile</td>
<td>执行编译</td>
<td>源代码编译在此阶段完成</td>
</tr>
<tr>
<td>test</td>
<td>测试</td>
<td>使用适当的单元测试框架(Unit)运行测试</td>
</tr>
<tr>
<td>package</td>
<td>打包</td>
<td>创建JAR&#x2F;WAR包如在pom.xml中定义提及的包</td>
</tr>
<tr>
<td>verify</td>
<td>检查</td>
<td>对集成测试的结果进行检查，以保证质量达标</td>
</tr>
<tr>
<td>install</td>
<td>安装</td>
<td>安装打包的项目到本地仓库，以供其他项目使用</td>
</tr>
<tr>
<td>deploy</td>
<td>部署</td>
<td>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td>
</tr>
</tbody></table>
<h2 id="6、说说你熟悉哪些maven命令"><a href="#6、说说你熟悉哪些maven命令" class="headerlink" title="6、说说你熟悉哪些maven命令"></a>6、说说你熟悉哪些maven命令</h2><p>mvn archetype:generate 创建 Maven项目</p>
<p>mvn compile 编译源代码 </p>
<p>mvn deploy 发布项目 </p>
<p>mvn test-compile 编译测试源代码 </p>
<p>mvn test 运行应用程序中的单元测试 </p>
<p>mvn site 生成项目相关信息的网站 </p>
<p>mvn clean 清除项目目录中的生成结果 </p>
<p>mvn package 根据项目生成的jar </p>
<p>mvn install 在本地 Repository中安装 jar </p>
<p>mvn eclipse:eclipse 生成 eclipse 项目文件 </p>
<p>mvnjetty :run 启动 jetty 服务 </p>
<p>mvntomcat :run 启动 tomcat服务 </p>
<p>mvn clean package-Dmaven.test.skip&#x3D;true：清除以前的包后重新打包，跳过测试类</p>
<h2 id="7、如何解决以来传递引起的版本冲突"><a href="#7、如何解决以来传递引起的版本冲突" class="headerlink" title="7、如何解决以来传递引起的版本冲突"></a>7、如何解决以来传递引起的版本冲突</h2><p>可通过dependency的exclusion元素排除掉依赖。</p>
<h2 id="8、说说maven的依赖原则"><a href="#8、说说maven的依赖原则" class="headerlink" title="8、说说maven的依赖原则"></a>8、说说maven的依赖原则</h2><ul>
<li>最短路径原则(依赖传递的路径越短越优先)；</li>
<li>pom文件申明顺序优先(路径长度一样，则先声明的优先)；</li>
<li>覆写原则(当前pom文件里声明的直接覆盖父工程传过来的)。</li>
</ul>
<h2 id="10、说说依赖的解析机制"><a href="#10、说说依赖的解析机制" class="headerlink" title="10、说说依赖的解析机制"></a>10、说说依赖的解析机制</h2><p>当依赖的范围是 system 的时候，Maven 直接从本地文件系统中解析构件。 根据依赖坐标计算仓库路径，尝试直接从本地仓库寻找构件，如果发现对应的构件，就解析成功。 如果在本地仓库不存在相应的构件，就遍历所有的远程仓库，发现后，下载并解析使用。 </p>
<p>如果依赖的版本是 RELEASE 或 LATEST，就基于更新策略读取所有远程仓库的元数据文 件 （ groupId&#x2F;artifactId&#x2F;maven-metadata.xml），将其与本地仓库的对应元合并后， 计算出 RELEASE 或者 LATEST 真实的值，然后基于该值检查本地仓库，或者从远程仓库 下载。 </p>
<p>如果依赖的版本是 SNAPSHOT，就基于更新策略读取所有远程仓库的元数据文件，将它与本地仓 库 对应的元数据合并，得到最新快照版本的值，然后根据该值检查本地仓库，或从远程仓库下载。 </p>
<p>如果最后解析得到的构件版本包含有时间戳，先将该文件下载下来，再将文件名中时间戳信息 删 除，剩下 SNAPSHOT 并使用（以非时间戳的形式使用）。</p>
<h2 id="11、说说插件的解析机制"><a href="#11、说说插件的解析机制" class="headerlink" title="11、说说插件的解析机制"></a>11、说说插件的解析机制</h2><p>与依赖的构件一样，插件也是基于坐标保存在Maven仓库中。在用到插件的时候会先从本地仓库 查 找插件，如果本地仓库没有则从远程仓库查找插件并下载到本地仓库。与普通的依赖构件不同 的 是，Maven会区别对待普通依赖的远程仓库与插件的远程仓库。前面提到的配置远程仓库只会对 普 通的依赖有效果。当Maven需要的插件在本地仓库不存在时是不会去我们以前配置的远程仓 库查找 插件的，而是需要有专门的插件远程仓库。</p>
<h1 id="九、Java框架"><a href="#九、Java框架" class="headerlink" title="九、Java框架"></a>九、Java框架</h1><h2 id="1、什么是Spirng"><a href="#1、什么是Spirng" class="headerlink" title="1、什么是Spirng"></a>1、什么是Spirng</h2><p>Spring时个java企业级应用的开源开发框架。Spirng主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring框架目标是简化java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p>
<h2 id="2、为什么使用Spring框架"><a href="#2、为什么使用Spring框架" class="headerlink" title="2、为什么使用Spring框架"></a>2、为什么使用Spring框架</h2><ul>
<li><strong>轻量：</strong>Spring是轻量的，基本的版本大约2MB</li>
<li><strong>控制反转</strong>(IOC)：Spring通过控制反转实现了松散耦合，对象们给出他们的依赖，而不是创建或查找依赖的对象们。</li>
<li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li>
<li><strong>容器</strong>：Spring包含并管理应用中对象的生命周期和配置。</li>
<li><strong>MVC框架</strong>：Spring的WEB框架是一个精心设计的框架，是Web框架的一个很好的替代品。</li>
<li><strong>事务管理：</strong>Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务。</li>
<li><strong>异常处理</strong>：Spring提供方便的API把具体技术相关的异常(如JDBC,Hibernate or JDO 抛出的)转化为一致的unchecked异常</li>
</ul>
<h2 id="3、Autowired和Resource关键字的区别"><a href="#3、Autowired和Resource关键字的区别" class="headerlink" title="3、Autowired和Resource关键字的区别"></a>3、Autowired和Resource关键字的区别</h2><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p>
<ol>
<li><p>共同点</p>
<p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p>
</li>
<li><p>不同点</p>
<ol>
<li><p>@Autowired</p>
<p>@Autowired 为 Spring 提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line">	<span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired注解是按照类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称(byName)来装配，可以结合@Qualifier注解一起使用。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="meta">@Qualifier(&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>@Resource</p>
<p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。</p>
<p>@Resource有两个重要的属性：name和type，而Spring将@Resource注解的属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果不指定name，也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> &#123;</span><br><span class="line"> <span class="comment">// 下面两种@Resource只要使用一种即可</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line"><span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123; <span class="comment">// 用于属性的 setter方法</span></span><br><span class="line">上 <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。</p>
<p>@Resource装配顺序：</p>
<ol>
<li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了name，则从上下文查找名称匹配的bean进行装配，找不到则抛出异常；</li>
<li>如果指定了type，则从上下文查找匹配的唯一bean进行装配，找不到或者找到多个，则抛出异常；</li>
<li>如果既没有指定name，有没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li>
</ol>
<p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p>
</li>
</ol>
</li>
</ol>
<h2 id="4、依赖注入的方式有几种，各是什么？"><a href="#4、依赖注入的方式有几种，各是什么？" class="headerlink" title="4、依赖注入的方式有几种，各是什么？"></a>4、<strong>依赖注入的方式有几种，各是什么？</strong></h2><p><strong>一、构造器注入将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。</strong></p>
<ul>
<li>优点：对象初始化完成后便可获得可使用的对象；</li>
<li>缺点：当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定的几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li>
</ul>
<p><strong>二、setter方法注入IOCservice Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。</strong></p>
<ul>
<li>优点：灵活。可以选择地注入需要的对象；</li>
<li>缺点：依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</li>
</ul>
<p><strong>三、接口注入依赖类必须实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。</strong></p>
<ul>
<li>优点：接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。</li>
<li>缺点：侵入性太强，不建议使用。</li>
</ul>
<h2 id="5、讲一下Spring是什么"><a href="#5、讲一下Spring是什么" class="headerlink" title="5、讲一下Spring是什么"></a>5、讲一下Spring是什么</h2><p>Spring是一个轻量级的IOC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需要。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。</p>
<p>主要有以下几个模块组成：</p>
<ul>
<li><strong>Spring Core：</strong>核心类库，提供IOC服务</li>
<li>**Spring Context:**提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）</li>
<li><strong>Spring AOP:</strong></li>
<li>**Spring DAO:**对JDBC的抽象，简化了数据访问异常的处理</li>
<li>**Spring ORM:**对现有的ORM框架的支持</li>
<li>**Spring Web:**提供了基本的面向Web的综合特征，例如多方文件上传</li>
<li>**Spring MVC:**提供面向Web应用的Model-View-Controller实现</li>
</ul>
<p><strong>Spring容器的主要核心</strong></p>
<ul>
<li><strong>控制反转(IOC)</strong>,传统的java开发模式中，当需要一个对象时，我们会自己使用 new 或者getInstance 等直接或者间接调用构造方法创建一个对象。而在spring开发 模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创 建了，直接调用 spring提供的对象就可以了，这是控制反转的思想。</li>
<li>**依赖注入(DI)**，spring 使用javaBean 对象的 set 方法或者带参数的构造方法为我们 在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</li>
<li>**面向切面编程(AOP),**在面向对象编程（oop）思想中，我们将事物纵向抽成一个个 的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切 面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理的过程就 是面向切面编程的思想。AOP底层是动态代理，如果是接口采用JDK动态代理，如果 是类采用 CGLIB方式实现动态代理。</li>
</ul>
<h2 id="6、说说你对Spring-MVC的理解"><a href="#6、说说你对Spring-MVC的理解" class="headerlink" title="6、说说你对Spring MVC的理解"></a>6、说说你对Spring MVC的理解</h2><p><strong>一、什么是MVC模式</strong></p>
<p>MVC：MVC是一种设计模式</p>
<p>MVC的原理图：</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20241011172113.png" alt="微信截图_20241011172113"></p>
<p><strong>分析：</strong></p>
<p>M-Model模型（完成业务逻辑：由javaBean构成，service+dao+entity）</p>
<p>V-View视图（做界面的展示jsp，html）</p>
<p>C-Controller控制器</p>
<p>springMVC是Spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单地把springMVC理解为是spring的一个模块。</p>
<p><strong>二、SpringMVC的工作流程：</strong></p>
<ol>
<li>用户发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li>
<li>处理器映射器找到具体的处理器,生成处理器对象及处理器拦截器（如果有则生成）一并返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter处理器适配器</li>
<li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）</li>
<li>Controller执行完成ModelAndView</li>
<li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>ViewReslover解析后返回具体View</li>
<li>DispatcherServlet根据View进行渲染视图</li>
<li>DispatcherServlet响应用户</li>
</ol>
<p><strong>三、SpringMVC如何返回JSON数据</strong></p>
<ol>
<li>在项目中加入json转换的依赖，例如jackson，fastjson，gson等</li>
<li>在请求处理方法中将返回值改为具体返回的数据的类型，例如数据的集合类List<Employee></Employee></li>
<li>在请求处理方法上使用@ResponseBody注解</li>
</ol>
<h2 id="7、说出Spring或者SpringMVC常用的五个注解"><a href="#7、说出Spring或者SpringMVC常用的五个注解" class="headerlink" title="7、说出Spring或者SpringMVC常用的五个注解"></a>7、说出Spring或者SpringMVC常用的五个注解</h2><ul>
<li>@Component 基本注解，标识一个受Spring管理的组件</li>
<li>@Controller                        标识为一个表示层的组件</li>
<li>@Service                              标识为一个业务层的组件</li>
<li>@Repository                        标识为一个持久层的组件</li>
<li>@Autowired                          自动装配</li>
<li>@Qualifier(“”)                       具体指定要装配的组件的id值</li>
<li>@RequestMapping()            完成请求映射</li>
<li>@PathVariable                      映射请求URL中占位符到请求处理方法的形参</li>
</ul>
<h2 id="8、Spring中常用的设计模式"><a href="#8、Spring中常用的设计模式" class="headerlink" title="8、Spring中常用的设计模式"></a>8、Spring中常用的设计模式</h2><ol>
<li>代理模式——spring中两种代理方式，若目标对象实现了若干接口，spring使用jdk的java.lang.reflect.Proxy类代理。若目标兑现没有实现任何接口，spring使用CGLIB库生成目标类的子类。</li>
<li>单例模式——在spring的配置文件中设置bean默认为单例模式。</li>
<li>模块方式模式——用来解决代码重复的问题。</li>
<li>比如：RestTemplate、JmsTemplate、JpaTemplate</li>
<li>工厂模式——在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用同一个接口来指向新创建的对象。Spring中使用beanFactory来创建对象的实例。</li>
</ol>
<h2 id="9、Spring-bean-的生命周期、注入方式和作用域"><a href="#9、Spring-bean-的生命周期、注入方式和作用域" class="headerlink" title="9、Spring bean 的生命周期、注入方式和作用域"></a>9、Spring bean 的生命周期、注入方式和作用域</h2><p><strong>Bean的生命周期</strong></p>
<ol>
<li>默认情况下，IOC容器中bean的生命周期分为五个阶段：<ul>
<li>调用构造器或者是通过工厂的方式创建Bean对象</li>
<li>给bean对象的属性注入值</li>
<li>调用初始化方法，进行初始化，初始化方法是通过init-method来指定的</li>
<li>使用</li>
<li>IOC容器关闭时，销毁Bean对象</li>
</ul>
</li>
<li>当加入Bean的后置处理器后，IOC容器中的bean的生命周期分为七个阶段：<ul>
<li>调用构造器或者通过工厂的方式创建Bean对象</li>
<li>给bean对象的属性注入值</li>
<li>执行Bean后置处理器中的postProcessBeforeInitialization</li>
<li>调用初始化方法，进行初始化，初始化方法是通过init-method来指定的</li>
<li>执行Bean的后置处理器中postProcessAfterInitialization</li>
<li>使用</li>
<li>IOC容器关闭时，销毁Bean对象</li>
</ul>
</li>
</ol>
<p><strong>注入方式</strong></p>
<p>通过setter方法注入</p>
<p>通过构造方法注入</p>
<p><strong>Bean的作用域</strong></p>
<ol>
<li>Singleton 单例的</li>
<li>Prototype 原型的</li>
<li>Request</li>
<li>Seesion</li>
</ol>
<h2 id="10、请描述一下Spring事务管理"><a href="#10、请描述一下Spring事务管理" class="headerlink" title="10、请描述一下Spring事务管理"></a>10、请描述一下Spring事务管理</h2><p>（1）声明式事务管理的定义：用在Spring配置文件中声明式的处理事务来代替代码式的处理事务。这样的好处是，事务管理部侵入开发的组件，具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可，这样维护起来极其方便。</p>
<p>基于TransactionInterceptor的声明式事务管理：两个次要的属性：</p>
<p>transactionManager，用来指定一个事务治理器，并将具体事务相关的操作请托给它；</p>
<p>其他一个是Properties类型的transactionAttributes属性，该属性的每一个键值对中，键指定的是方法名，方法名可以行使通配符，而值就是表现呼应方法的所运用的事务属性。</p>
<p>（2）基于@Transactional的声明式事务管理：Spring2.x还引入基于Annotation的体式格式，具体要触及@Transactional标注。@Transactional可以浸染于接口、接口方法、类和类方法上。算作用于类上时，该类的一切public方法将都具有该类型的事务属性。</p>
<p>（3）编程式事务管理的定义：在代码中显示挪用beginTransaction（）、commit（）、rollback（）等事务治理相关的方法，这就是编程式事务管理。Spring对事物的编程式管理有基于底层API的编程式管理和基于TransactionTemplate的编程式事务管理两种方式。</p>
<h2 id="11、Mybatis中-和-区别是什么"><a href="#11、Mybatis中-和-区别是什么" class="headerlink" title="11、Mybatis中#{}和${}区别是什么"></a>11、Mybatis中#{}和${}区别是什么</h2><p>#{}是预编译处理，${}是字符串替换；</p>
<p>Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；</p>
<p> Mybatis 在处理${}时，就是把它替换成变量的值；</p>
<p> 使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>
<h2 id="12、Mybatis如何获取自动生成的主键值"><a href="#12、Mybatis如何获取自动生成的主键值" class="headerlink" title="12、Mybatis如何获取自动生成的主键值"></a>12、Mybatis如何获取自动生成的主键值</h2><p>在标签中使用 useGeneratedKeys 和 keyProperty 两个属性来获取自动生成的 主键值。 示例: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert id=”insertname” usegeneratedkeys=”<span class="literal">true</span>” keyproperty=”id”&gt;</span><br><span class="line">insert into <span class="title function_">names</span> <span class="params">(name)</span> values (#&#123;name&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<h2 id="13、简述Mybatis的动态sql，列出常用的六个标签及作用"><a href="#13、简述Mybatis的动态sql，列出常用的六个标签及作用" class="headerlink" title="13、简述Mybatis的动态sql，列出常用的六个标签及作用"></a>13、简述Mybatis的动态sql，列出常用的六个标签及作用</h2><p>动态 SQL 是 MyBatis 的强大特性之一 基于功能强大的 OGNL 表达式。 </p>
<p>动态 SQL 主要是来解决查询条件不确定的情况，在程序运行期间，根据提交的条件动 态的完成查询 </p>
<p>常用的标签: </p>
<p><if>: 进行条件的判断</if></p>
<p><where>：在判断后的 SQL 语句前面添加 WHERE 关键字，并处理 SQL 语句开 始位置的 AND 或者 OR 的问题</where></p>
<p> <trim>：可以在 SQL 语句前后进行添加指定字符 或者去掉指定字符. </trim></p>
<p><set>: 主要用于修改操作时出现的逗号问题  </set></p>
<p><choose>：类似于 java 中的 switch 语句.在所有的条件中选 择其一 </choose></p>
<p><foreach>：迭代操作</foreach></p>
<h2 id="13、Mybatis-如何完成-MySQL的批量操作"><a href="#13、Mybatis-如何完成-MySQL的批量操作" class="headerlink" title="13、Mybatis 如何完成 MySQL的批量操作"></a>13、Mybatis 如何完成 MySQL的批量操作</h2><p>MyBatis 完成 MySQL 的批量操作主要是通过标签来拼装相应的 SQL 语句 </p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert** id=<span class="string">&quot;insertBatch&quot;</span> &gt;</span><br><span class="line">insert into <span class="title function_">tbl_employee</span><span class="params">(last_name,email,gender,d_id)</span> values</span><br><span class="line">&lt;foreach** collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;curr_emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>**&gt;</span><br><span class="line">(#&#123;curr_emp.lastName&#125;,#&#123;curr_emp.email&#125;,#&#123;curr_emp.gender&#125;,#&#123;curr_emp.dept.id&#125;</span><br><span class="line">)</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;`</span><br></pre></td></tr></table></figure>

<h2 id="14、谈谈怎么理解SpringBoot框架"><a href="#14、谈谈怎么理解SpringBoot框架" class="headerlink" title="14、谈谈怎么理解SpringBoot框架"></a>14、谈谈怎么理解SpringBoot框架</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是 简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上 手。</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/image-20241105154012436.png" alt="image-20241105154012436"></p>
<p><strong>Spring Boot的优点</strong> </p>
<ul>
<li><p>独立运行 </p>
<p>Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成 war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依 赖包都在一个 jar 包内。</p>
</li>
<li><p>简化配置</p>
</li>
</ul>
<p>  spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置。除此之 外，还提供了各种启动器，开发者能快速上手。</p>
<ul>
<li>自动配置</li>
</ul>
<p>  Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring- boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。</p>
<ul>
<li>无代码生成和 XML 配置</li>
</ul>
<p>  Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作， 这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。</p>
<ul>
<li>应用监控</li>
</ul>
<p>  Spring Boot 提供一系列端点可以监控服务及应用，做健康检测。</p>
<p> <strong>Spring Boot缺点：</strong> </p>
<p>Spring Boot 虽然上手很容易，但如果你不了解其核心技术及流程，所以一旦遇到问题 就很棘手，而且现在的解决方案也不是很多，需要一个完善的过程。</p>
<h2 id="15、Spring-Boot-的核心注解是哪个-它主要由哪几个注解-组成的"><a href="#15、Spring-Boot-的核心注解是哪个-它主要由哪几个注解-组成的" class="headerlink" title="15、Spring Boot 的核心注解是哪个 它主要由哪几个注解 组成的"></a>15、Spring Boot 的核心注解是哪个 它主要由哪几个注解 组成的</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要 组合包含了以下 3 个注解：</p>
<ul>
<li><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功 能。 </p>
</li>
<li><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置 的选项， </p>
<p>如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。 </p>
</li>
<li><p>@ComponentScan：Spring 组件扫描</p>
</li>
</ul>
<h2 id="16、Spring-Boot自动配置原理是什么"><a href="#16、Spring-Boot自动配置原理是什么" class="headerlink" title="16、Spring Boot自动配置原理是什么"></a>16、Spring Boot自动配置原理是什么</h2><p>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配 置的核心， </p>
<p>首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。 @EnableAutoConfiguration 是实现自动配置的注解 </p>
<p>@Configuration 表示这是一个配置文件 </p>
<p>具体参考文档：</p>
<p>[<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484365&idx=1">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484365&amp;idx=1</a> &amp;sn&#x3D;a4ab1d977d6b03bf122b4d596d7ee1ab&amp;scene&#x3D;21](<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247484365&idx=1">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484365&amp;idx=1</a><br>&amp;sn&#x3D;a4ab1d977d6b03bf122b4d596d7ee1ab&amp;scene&#x3D;21)</p>
<h2 id="17、SpringBoot和-SpringCloud是什么关系"><a href="#17、SpringBoot和-SpringCloud是什么关系" class="headerlink" title="17、SpringBoot和 SpringCloud是什么关系"></a>17、SpringBoot和 SpringCloud是什么关系</h2><p>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个 微服务，Spring Cloud 是一个基于 Spring Boot 实现的开发工具；Spring Boot 专注于 快速、方便集成的单个微服务个体，Spring Cloud 关注全局的服务治理框架； Spring Boot 使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配 置，Spring Cloud 很大的一部分是基于 Spring Boot 来实现，必须基于 Spring Boot 开 发。 </p>
<p>可以单独使用 Spring Boot 开发项目，但是 Spring Cloud 离不开 Spring Boot。</p>
<h2 id="18、SpringCloud都用过哪些组件-介绍一下作用"><a href="#18、SpringCloud都用过哪些组件-介绍一下作用" class="headerlink" title="18、SpringCloud都用过哪些组件 介绍一下作用"></a>18、SpringCloud都用过哪些组件 介绍一下作用</h2><ul>
<li>(1) Nacos–作为注册中心和配置中心，实现服务注册发现和服务健康监测及配置信息 统一管理 </li>
<li>(2) Gateway–作为网关，作为分布式系统统一的出入口，进行服务路由，统一鉴权等</li>
<li>(3) OpenFeign–作为远程调用的客户端，实现服务之间的远程调用 </li>
<li>(4) Sentinel–实现系统的熔断限流</li>
<li>(5) Sleuth–实现服务的链路追踪</li>
</ul>
<h2 id="19、Nacos作用以及注册中心的原理"><a href="#19、Nacos作用以及注册中心的原理" class="headerlink" title="19、Nacos作用以及注册中心的原理"></a>19、Nacos作用以及注册中心的原理</h2><p>Nacos 英文全称 Dynamic Naming and Configuration Service，Na 为 naming&#x2F;nameServer 即注册中心,co 为 configuration 即注册中心，service 是指该注册 &#x2F;配置中心都是以服务为核心。 </p>
<p>Nacos 注册中心分为 server 与 client，server 采用 Java 编写，为 client 提供注册发 现服务与配置服务。而 client 可以用多语言实现，client 与微服务嵌套在一起，nacos 提供 sdk 和 openApi，如果没有 sdk 也可以根据 openApi 手动写服务注册与发现和配 置拉取的逻辑。</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/image-20241112184133630.png" alt="image-20241112184133630"></p>
<p><strong>服务注册原理</strong></p>
<p>服务注册方法：以 Java nacos client v1.0.1 为例子，服务注册的策略的是每 5 秒向 nacos server 发送一次心跳，心跳带上了服务名，服务 ip，服务端口等信息。同时 nacos server 也会向 client 主动发起健康检查，支持 tcp&#x2F;http 检查。如果 15 秒内无 心跳且健康检查失败则认为实例不健康，如果 30 秒内健康检查失败则剔除实例。</p>
<p><img src="/img/loading.gif" data-original="/2024/10/10/bagu/image-20241112184253717.png" alt="image-20241112184253717"></p>
<h2 id="20、Feign工作原理"><a href="#20、Feign工作原理" class="headerlink" title="20、Feign工作原理"></a>20、Feign工作原理</h2><p>主程序入口添加了@EnableFeignClients 注解开启对 FeignClient 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加@FeignClient 注解。当程序启动时，会进行包扫 描，扫描所有@FeignClient 的注解的类，并且讲这些信息注入 Spring IOC 容器中，当定义 的的 Feign 接口中的方法被调用时，通过 JDK 的代理方式，来生成具体的 RequestTemplate. 当生成代理时，Feign 会为每个接口方法创建一个 RequestTemplate 对象，该对象封装 HTTP 请求需要的全部信息，如请求参数名，请求方法等信息都是在这个过程中确定的。 然后 RequestTemplate 生成 Request,然后把 Request 交给 Client 去处理，这里指的时 Client 可以时 JDK 原生的 URLConnection,Apache 的 HttpClient,也可以时 OKhttp，最后 Client 被封装到 LoadBalanceClient 类，这个类结合 Ribbon 负载均衡发器服务之间的调 用。</p>
<img src="/img/loading.gif" data-original="/2024/10/10/bagu/image-20241112184501662.png" alt="image-20241112184501662" style="zoom:50%;">



<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://hierWxy.github.io">草木流年</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://hierwxy.github.io/2024/10/10/bagu/">http://hierwxy.github.io/2024/10/10/bagu/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hierWxy.github.io" target="_blank">木叶村</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/head.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/20/JavaWeb/" title="JavaWeb"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaWeb</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/30/hmdp/" title="hmdp"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hmdp</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">草木流年</div><div class="author-info__description">未来可期</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2624477928@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80"><span class="toc-text">一、Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2.重载和重写方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Java%E4%B8%ADhashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%92%8C-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3.Java中hashCode和equals方法是什么？和&#x3D;&#x3D;有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-text">4.异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">5.Java优势是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%9C%B0%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7"><span class="toc-text">6.什么是Java地多态特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-HashMap%E5%8E%9F%E7%90%86"><span class="toc-text">7.HashMap原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">8.面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Java%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-text">9.Java的自动装箱和拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Hashcode%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">10.Hashcode的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">12.HashMap和HashTable的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%B8%A4%E8%80%85%E7%88%B6%E7%B1%BB%E4%B8%8D%E5%90%8C"><span class="toc-text">1、两者父类不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9B%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E5%90%8C"><span class="toc-text">2、对外提供的接口不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9null%E7%9A%84%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C"><span class="toc-text">3、对null的支持不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E5%90%8C"><span class="toc-text">4、安全性不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E5%92%8C%E6%AF%8F%E6%AC%A1%E6%89%A9%E5%85%85%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F%E4%B8%8D%E5%90%8C"><span class="toc-text">5、初始容量大小和每次扩充容量大小不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%AE%A1%E7%AE%97hash%E5%80%BC%E6%96%B9%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-text">6、计算hash值方法不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-text">13、泛型常用特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">14、Java创建对象有几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD%E4%B8%A4%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84hashcode"><span class="toc-text">15、有没有可能两个不相等的对象有相同的hashcode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">16、深拷贝和浅拷贝的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81final%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">17、final的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81a-a-b%E5%92%8Ca-b%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">18、a&#x3D;a+b和a+&#x3D;b有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81try-catch-finally-try%E9%87%8C%E6%9C%89return-finally%E8%BF%98%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">19、try catch finally,try里有return,finally还执行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81Excption%E4%B8%8EError%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-text">20、Excption与Error包结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E3%80%81OOM%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8CSOF%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5"><span class="toc-text">21、OOM你遇到过哪些情况，SOF你遇到过哪些情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E3%80%81%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">22、简述线程、程序、进程的基本概念。以及他们之间关系是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E3%80%81%E3%80%81Java%E4%B8%ADIO%E6%B5%81"><span class="toc-text">23、、Java中IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E3%80%81Java%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8E%9F%E7%90%86"><span class="toc-text">24、Java反射的作用原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E3%80%81List%EF%BC%8CSet%EF%BC%8CMap%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-text">25、List，Set，Map三者区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">二、Java多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81JVM"><span class="toc-text">三、JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB"><span class="toc-text">1、知识点汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E8%A7%A3"><span class="toc-text">2、知识点详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.JVM内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88"><span class="toc-text">2.栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Mysql"><span class="toc-text">四、Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81select%E8%AF%AD%E5%8F%A5%E5%AE%8C%E6%95%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">1、select语句完整的执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81MySQL%E4%BA%8B%E5%8A%A1"><span class="toc-text">2、MySQL事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">4、悲观锁和乐观锁怎么实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Redis"><span class="toc-text">五、Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-text">1、为什么要用缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BRedis%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-text">2、说一下Redis有什么优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRedis"><span class="toc-text">3、什么是Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%95%88%E7%8E%87%E4%B9%9F%E8%83%BD%E9%82%A3%E4%B9%88%E9%AB%98"><span class="toc-text">4、为什么Redis单线程模型效率也能那么高</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E8%AF%B4Redis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B-%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">5、说说Redis的线程模型(基于非阻塞的IO复用模型机制)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E9%9C%80%E8%A6%81%E6%8A%8A%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E6%94%BE%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9F"><span class="toc-text">6、为什么Redis需要把所有数据放到内存中？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">7、Redis的同步机制是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Redis%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">8、Redis缓存刷新策略有哪些</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%B3%BB%E5%88%97"><span class="toc-text">六、计算机网络系列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81linux"><span class="toc-text">七、linux</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81maven%E7%AF%87"><span class="toc-text">八、maven篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmaven%EF%BC%9F"><span class="toc-text">1、什么是maven？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81maven%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-text">2、maven能为我们解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%AF%B4%E8%AF%B4maven%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3、说说maven有什么优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmaven%E5%9D%90%E6%A0%87"><span class="toc-text">4、什么是maven坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%AE%B2%E4%B8%80%E4%B8%8Bmaven%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">5、讲一下maven的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%86%9F%E6%82%89%E5%93%AA%E4%BA%9Bmaven%E5%91%BD%E4%BB%A4"><span class="toc-text">6、说说你熟悉哪些maven命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BB%A5%E6%9D%A5%E4%BC%A0%E9%80%92%E5%BC%95%E8%B5%B7%E7%9A%84%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81"><span class="toc-text">7、如何解决以来传递引起的版本冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E8%AF%B4%E8%AF%B4maven%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8E%9F%E5%88%99"><span class="toc-text">8、说说maven的依赖原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="toc-text">10、说说依赖的解析机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%AF%B4%E8%AF%B4%E6%8F%92%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="toc-text">11、说说插件的解析机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Java%E6%A1%86%E6%9E%B6"><span class="toc-text">九、Java框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpirng"><span class="toc-text">1、什么是Spirng</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Spring%E6%A1%86%E6%9E%B6"><span class="toc-text">2、为什么使用Spring框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Autowired%E5%92%8CResource%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、Autowired和Resource关键字的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%90%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4、依赖注入的方式有几种，各是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E8%AE%B2%E4%B8%80%E4%B8%8BSpring%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">5、讲一下Spring是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring-MVC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">6、说说你对Spring MVC的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%AF%B4%E5%87%BASpring%E6%88%96%E8%80%85SpringMVC%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%94%E4%B8%AA%E6%B3%A8%E8%A7%A3"><span class="toc-text">7、说出Spring或者SpringMVC常用的五个注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">8、Spring中常用的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81Spring-bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">9、Spring bean 的生命周期、注入方式和作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E8%AF%B7%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">10、请描述一下Spring事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Mybatis%E4%B8%AD-%E5%92%8C-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">11、Mybatis中#{}和${}区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Mybatis%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%B8%BB%E9%94%AE%E5%80%BC"><span class="toc-text">12、Mybatis如何获取自动生成的主键值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E7%AE%80%E8%BF%B0Mybatis%E7%9A%84%E5%8A%A8%E6%80%81sql%EF%BC%8C%E5%88%97%E5%87%BA%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%AD%E4%B8%AA%E6%A0%87%E7%AD%BE%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-text">13、简述Mybatis的动态sql，列出常用的六个标签及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81Mybatis-%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90-MySQL%E7%9A%84%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-text">13、Mybatis 如何完成 MySQL的批量操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E8%B0%88%E8%B0%88%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3SpringBoot%E6%A1%86%E6%9E%B6"><span class="toc-text">14、谈谈怎么理解SpringBoot框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E3%80%81Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA-%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3-%E7%BB%84%E6%88%90%E7%9A%84"><span class="toc-text">15、Spring Boot 的核心注解是哪个 它主要由哪几个注解 组成的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E3%80%81Spring-Boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">16、Spring Boot自动配置原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E3%80%81SpringBoot%E5%92%8C-SpringCloud%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-text">17、SpringBoot和 SpringCloud是什么关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E3%80%81SpringCloud%E9%83%BD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%9C%E7%94%A8"><span class="toc-text">18、SpringCloud都用过哪些组件 介绍一下作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E3%80%81Nacos%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">19、Nacos作用以及注册中心的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E3%80%81Feign%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">20、Feign工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/12/%E9%9D%A2%E8%AF%95%E9%A2%981/" title="面试题1">面试题1</a><time datetime="2024-11-12T07:47:24.000Z" title="发表于 2024-11-12 15:47:24">2024-11-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/20/JavaWeb/" title="JavaWeb">JavaWeb</a><time datetime="2024-10-20T07:20:14.000Z" title="发表于 2024-10-20 15:20:14">2024-10-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/10/bagu/" title="bagu">bagu</a><time datetime="2024-10-10T08:25:51.000Z" title="发表于 2024-10-10 16:25:51">2024-10-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/30/hmdp/" title="hmdp">hmdp</a><time datetime="2024-09-30T14:30:01.000Z" title="发表于 2024-09-30 22:30:01">2024-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/27/leetcode/" title="leetcode">leetcode</a><time datetime="2024-09-27T12:04:31.000Z" title="发表于 2024-09-27 20:04:31">2024-09-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 草木流年</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2567772154" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>